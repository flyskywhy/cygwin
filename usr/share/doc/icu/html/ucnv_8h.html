<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ICU 3.8: ucnv.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ucnv.h File Reference</h1>C API: Character conversion. <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="ucnv__err_8h-source.html">unicode/ucnv_err.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="uenum_8h-source.html">unicode/uenum.h</a>&quot;</code><br>

<p>
<a href="ucnv_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#3ab00bb423db8533da12c35848e4c281">UCNV_MAX_CONVERTER_NAME_LENGTH</a>&nbsp;&nbsp;&nbsp;60</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum length of a converter name including the terminating NULL.  <a href="#3ab00bb423db8533da12c35848e4c281"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#1a579f67d05b09f731df5a68eb80b851">UCNV_MAX_FULL_FILE_NAME_LENGTH</a>&nbsp;&nbsp;&nbsp;(600+UCNV_MAX_CONVERTER_NAME_LENGTH)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum length of a converter name including path and terminating NULL.  <a href="#1a579f67d05b09f731df5a68eb80b851"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#082aba7f50746ff6135a4ca2a00f6d6c">UCNV_SI</a>&nbsp;&nbsp;&nbsp;0x0F</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift in for EBDCDIC_STATEFUL and iso2022 states.  <a href="#082aba7f50746ff6135a4ca2a00f6d6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#d3918524388c8100107273806bd58c65">UCNV_SO</a>&nbsp;&nbsp;&nbsp;0x0E</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift out for EBDCDIC_STATEFUL and iso2022 states.  <a href="#d3918524388c8100107273806bd58c65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#420028eb5f83222307bf16632857b148">UCNV_OPTION_SEP_CHAR</a>&nbsp;&nbsp;&nbsp;','</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Character that separates converter names from options and options from each other.  <a href="#420028eb5f83222307bf16632857b148"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#8f221dc37208cc5c5e9b1d72a7103435">UCNV_OPTION_SEP_STRING</a>&nbsp;&nbsp;&nbsp;&quot;,&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">String version of UCNV_OPTION_SEP_CHAR.  <a href="#8f221dc37208cc5c5e9b1d72a7103435"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#92803b44385721ec771befc01b5e8e3b">UCNV_VALUE_SEP_CHAR</a>&nbsp;&nbsp;&nbsp;'='</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Character that separates a converter option from its value.  <a href="#92803b44385721ec771befc01b5e8e3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#33cd53c804d95e14388398843e6edc82">UCNV_VALUE_SEP_STRING</a>&nbsp;&nbsp;&nbsp;&quot;=&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">String version of UCNV_VALUE_SEP_CHAR.  <a href="#33cd53c804d95e14388398843e6edc82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#867b3f44513565bca406eebe2f87ee99">UCNV_LOCALE_OPTION_STRING</a>&nbsp;&nbsp;&nbsp;&quot;,locale=&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converter option for specifying a locale.  <a href="#867b3f44513565bca406eebe2f87ee99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#c7b80fb72078403f8bdba322b63a5a93">UCNV_VERSION_OPTION_STRING</a>&nbsp;&nbsp;&nbsp;&quot;,version=&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converter option for specifying a version selector (0.  <a href="#c7b80fb72078403f8bdba322b63a5a93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#0588f7014923ad969821941f9dd51040">UCNV_SWAP_LFNL_OPTION_STRING</a>&nbsp;&nbsp;&nbsp;&quot;,swaplfnl&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converter option for EBCDIC SBCS or mixed-SBCS/DBCS (stateful) codepages.  <a href="#0588f7014923ad969821941f9dd51040"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#b6ef5c3c7c83982313e415e697a26089">U_CNV_SAFECLONE_BUFFERSIZE</a>&nbsp;&nbsp;&nbsp;1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Definition of a buffer size that is designed to be large enough for converters to be cloned with <a class="el" href="ucnv_8h.html#11a66c267dce12a78dac2690d983d69e" title="Thread safe converter cloning operation.">ucnv_safeClone()</a>.  <a href="#b6ef5c3c7c83982313e415e697a26089"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a3d7e4ae84f8a95b9735ed3491cdb77e">UCNV_GET_MAX_BYTES_FOR_STRING</a>(length, maxCharSize)&nbsp;&nbsp;&nbsp;(((int32_t)(length)+10)*(int32_t)(maxCharSize))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the size of a buffer for conversion from Unicode to a charset.  <a href="#a3d7e4ae84f8a95b9735ed3491cdb77e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="uset_8h.html#dce3fef7c15d7c78196bf977ac96ec9c">USet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#dce3fef7c15d7c78196bf977ac96ec9c">USet</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d4cc7d74b57ff7423aeafb667489ec00"></a><!-- doxytag: member="ucnv.h::args" ref="d4cc7d74b57ff7423aeafb667489ec00" args="" -->
typedef <a class="el" href="structUConverterToUnicodeArgs.html">UConverterToUnicodeArgs</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>args</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5436c8fba723a7f4bcee24ca2b1ba892"></a><!-- doxytag: member="ucnv.h::codeUnits" ref="5436c8fba723a7f4bcee24ca2b1ba892" args="" -->
typedef <br>
<a class="el" href="structUConverterToUnicodeArgs.html">UConverterToUnicodeArgs</a> const <br>
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>codeUnits</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2b811fa5f6e9b580fa0122d38e9849b5"></a><!-- doxytag: member="ucnv.h::length" ref="2b811fa5f6e9b580fa0122d38e9849b5" args="" -->
typedef <br>
<a class="el" href="structUConverterToUnicodeArgs.html">UConverterToUnicodeArgs</a> const <br>
char int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>length</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0fa42b778680dd0d192f1a4982fd6812"></a><!-- doxytag: member="ucnv.h::reason" ref="0fa42b778680dd0d192f1a4982fd6812" args="" -->
typedef <br>
<a class="el" href="structUConverterToUnicodeArgs.html">UConverterToUnicodeArgs</a> const <br>
char int32_t <br>
<a class="el" href="ucnv__err_8h.html#19e1a4d55a7679634e84b241b00de01a">UConverterCallbackReason</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>reason</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7c719ea4b47ee0fd376e4dee588456c6"></a><!-- doxytag: member="ucnv.h::pErrorCode" ref="7c719ea4b47ee0fd376e4dee588456c6" args="" -->
typedef <br>
<a class="el" href="structUConverterToUnicodeArgs.html">UConverterToUnicodeArgs</a> const <br>
char int32_t <br>
<a class="el" href="ucnv__err_8h.html#19e1a4d55a7679634e84b241b00de01a">UConverterCallbackReason</a> <br>
<a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pErrorCode</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e70a5e13708a55a38c8b83046e32af6c"></a><!-- doxytag: member="ucnv.h::codePoint" ref="e70a5e13708a55a38c8b83046e32af6c" args="" -->
typedef <br>
<a class="el" href="structUConverterFromUnicodeArgs.html">UConverterFromUnicodeArgs</a> <br>
const UChar int32_t <a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>codePoint</b></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#db0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a> { <br>
&nbsp;&nbsp;<b>UCNV_UNSUPPORTED_CONVERTER</b> =  -1, 
<b>UCNV_SBCS</b> =  0, 
<b>UCNV_DBCS</b> =  1, 
<b>UCNV_MBCS</b> =  2, 
<br>
&nbsp;&nbsp;<b>UCNV_LATIN_1</b> =  3, 
<b>UCNV_UTF8</b> =  4, 
<b>UCNV_UTF16_BigEndian</b> =  5, 
<b>UCNV_UTF16_LittleEndian</b> =  6, 
<br>
&nbsp;&nbsp;<b>UCNV_UTF32_BigEndian</b> =  7, 
<b>UCNV_UTF32_LittleEndian</b> =  8, 
<b>UCNV_EBCDIC_STATEFUL</b> =  9, 
<b>UCNV_ISO_2022</b> =  10, 
<br>
&nbsp;&nbsp;<b>UCNV_LMBCS_1</b> =  11, 
<b>UCNV_LMBCS_2</b>, 
<b>UCNV_LMBCS_3</b>, 
<b>UCNV_LMBCS_4</b>, 
<br>
&nbsp;&nbsp;<b>UCNV_LMBCS_5</b>, 
<b>UCNV_LMBCS_6</b>, 
<b>UCNV_LMBCS_8</b>, 
<b>UCNV_LMBCS_11</b>, 
<br>
&nbsp;&nbsp;<b>UCNV_LMBCS_16</b>, 
<b>UCNV_LMBCS_17</b>, 
<b>UCNV_LMBCS_18</b>, 
<b>UCNV_LMBCS_19</b>, 
<br>
&nbsp;&nbsp;<b>UCNV_LMBCS_LAST</b> =  UCNV_LMBCS_19, 
<b>UCNV_HZ</b>, 
<b>UCNV_SCSU</b>, 
<b>UCNV_ISCII</b>, 
<br>
&nbsp;&nbsp;<b>UCNV_US_ASCII</b>, 
<b>UCNV_UTF7</b>, 
<b>UCNV_BOCU1</b>, 
<b>UCNV_UTF16</b>, 
<br>
&nbsp;&nbsp;<b>UCNV_UTF32</b>, 
<b>UCNV_CESU8</b>, 
<b>UCNV_IMAP_MAILBOX</b>, 
<b>UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES</b>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enum for specifying basic types of converters.  <a href="ucnv_8h.html#db0b44c6bd828c9d4cc2defcbba0f902">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a> { <b>UCNV_UNKNOWN</b> =  -1, 
<b>UCNV_IBM</b> =  0
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enum for specifying which platform a converter ID refers to.  <a href="ucnv_8h.html#ba5ba7fbc2f113618ba57f4d9825ff85">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a> { <a class="el" href="ucnv_8h.html#402221896b6d7153b14a5ff8dadde806b08c09dd129a92d08725b5260b49cbf9">UCNV_ROUNDTRIP_SET</a>, 
<a class="el" href="ucnv_8h.html#402221896b6d7153b14a5ff8dadde80633cced69d47e6de3cbfd79d17f88fcaf">UCNV_SET_COUNT</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Selectors for Unicode sets that can be returned by <a class="el" href="ucnv_8h.html#ec7c273c8ce917ff75224e25914c53be" title="Returns the set of Unicode code points that can be converted by an ICU converter...">ucnv_getUnicodeSet()</a>.  <a href="ucnv_8h.html#402221896b6d7153b14a5ff8dadde806">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a953bd3cedaedf78b700c837361fe00b">void</a> (1 *UConverterToUCallback)(const void *context</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function pointer for error callback in the codepage to unicode direction.  <a href="#a953bd3cedaedf78b700c837361fe00b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#6f998746d8a8a8afd837f04dbb1ab64a">ucnv_compareNames</a> (const char *name1, const char *name2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do a fuzzy compare of two converter/alias names.  <a href="#6f998746d8a8a8afd837f04dbb1ab64a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41">ucnv_open</a> (const char *converterName, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a UConverter object with the name of a coded character set specified as a C string.  <a href="#485c78d4149165f504effa2287717e41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#82e86d5341b39c543c269c70b8310f3e">ucnv_openU</a> (const UChar *name, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a Unicode converter with the names specified as unicode string.  <a href="#82e86d5341b39c543c269c70b8310f3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#9df0109e866c32078ab96fd2fe994b15">ucnv_openCCSID</a> (int32_t codepage, <a class="el" href="ucnv_8h.html#ba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a> platform, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a UConverter object from a CCSID number and platform pair.  <a href="#9df0109e866c32078ab96fd2fe994b15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#7e3fc1e59ac1404120f242b8911cadbb">ucnv_openPackage</a> (const char *packageName, const char *converterName, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#11a66c267dce12a78dac2690d983d69e">ucnv_safeClone</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, void *stackBuffer, int32_t *pBufferSize, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread safe converter cloning operation.  <a href="#11a66c267dce12a78dac2690d983d69e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#1718689bf60724fdfa08c51aa0cc5ea0">ucnv_close</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the unicode converter and releases resources associated with just this instance.  <a href="#1718689bf60724fdfa08c51aa0cc5ea0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#118a87477ffa827d00dd50727da02e31">ucnv_getSubstChars</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, char *subChars, int8_t *len, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills in the output parameter, subChars, with the substitution characters as multiple bytes.  <a href="#118a87477ffa827d00dd50727da02e31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#c160b1b44ac9b5124ec083810709603a">ucnv_setSubstChars</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, const char *subChars, int8_t len, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the substitution chars when converting from unicode to a codepage.  <a href="#c160b1b44ac9b5124ec083810709603a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#f87333c550d699794ab84151ed9007c6">ucnv_setSubstString</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, const UChar *s, int32_t length, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a substitution string for converting from Unicode to a charset.  <a href="#f87333c550d699794ab84151ed9007c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#e8c925ce8f47ab08c53f9e3b3b9664f4">ucnv_getInvalidChars</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, char *errBytes, int8_t *len, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills in the output parameter, errBytes, with the error characters from the last failing conversion.  <a href="#e8c925ce8f47ab08c53f9e3b3b9664f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#341f4716c12e62d24cc8431eb9dfecdd">ucnv_getInvalidUChars</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, UChar *errUChars, int8_t *len, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills in the output parameter, errChars, with the error characters from the last failing conversion.  <a href="#341f4716c12e62d24cc8431eb9dfecdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ce43ec88f1615422f3c5c972ae79deba">ucnv_reset</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the state of a converter to the default state.  <a href="#ce43ec88f1615422f3c5c972ae79deba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#8711b61a6cd41d84cf522042b3aebaed">ucnv_resetToUnicode</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the to-Unicode part of a converter state to the default state.  <a href="#8711b61a6cd41d84cf522042b3aebaed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ba8147239dca1fe5773de4905f2f74c2">ucnv_resetFromUnicode</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the from-Unicode part of a converter state to the default state.  <a href="#ba8147239dca1fe5773de4905f2f74c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#11007a7bcc41b1030cda0ee28fe78195">ucnv_getMaxCharSize</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum number of bytes that are output per UChar in conversion from Unicode using this converter.  <a href="#11007a7bcc41b1030cda0ee28fe78195"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#12edd465a611c41e418632f5d5f2dbe4">ucnv_getMinCharSize</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the minimum byte length for characters in this codepage.  <a href="#12edd465a611c41e418632f5d5f2dbe4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#36c33bb6459c126f64e5472c6e5023a6">ucnv_getDisplayName</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, const char *displayLocale, UChar *displayName, int32_t displayNameCapacity, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the display name of the converter passed in based on the <a class="el" href="classLocale.html" title="A Locale object represents a specific geographical, political, or cultural region...">Locale</a> passed in.  <a href="#36c33bb6459c126f64e5472c6e5023a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ac2e332117c919a01516c726c051dd55">ucnv_getName</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the internal, canonical name of the converter (zero-terminated).  <a href="#ac2e332117c919a01516c726c051dd55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#0500738a0f4a552725725f9fe964e430">ucnv_getCCSID</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a codepage number associated with the converter.  <a href="#0500738a0f4a552725725f9fe964e430"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ucnv_8h.html#ba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a14f20f0ffa7f602690956cf3a5c87e2">ucnv_getPlatform</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a codepage platform associated with the converter.  <a href="#a14f20f0ffa7f602690956cf3a5c87e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ucnv_8h.html#db0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#94a8af5dd3516cea50c2829e6c35b397">ucnv_getType</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the type of the converter e.g.  <a href="#94a8af5dd3516cea50c2829e6c35b397"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a970dda00a55c1751b7fe0bb34b04015">ucnv_getStarters</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> starters[256], <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the "starter" (lead) bytes for converters of type MBCS.  <a href="#a970dda00a55c1751b7fe0bb34b04015"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ec7c273c8ce917ff75224e25914c53be">ucnv_getUnicodeSet</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="uset_8h.html#dce3fef7c15d7c78196bf977ac96ec9c">USet</a> *setFillIn, <a class="el" href="ucnv_8h.html#402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a> whichSet, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the set of Unicode code points that can be converted by an ICU converter.  <a href="#ec7c273c8ce917ff75224e25914c53be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#f45faec39053767f4a7a779586c24223">ucnv_getToUCallBack</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, UConverterToUCallback *action, const void **context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current calback function used by the converter when an illegal or invalid codepage sequence is found.  <a href="#f45faec39053767f4a7a779586c24223"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#2a2dcbf10e3b08a97ed0b06466d9e8a5">ucnv_getFromUCallBack</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, UConverterFromUCallback *action, const void **context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current callback function used by the converter when illegal or invalid Unicode sequence is found.  <a href="#2a2dcbf10e3b08a97ed0b06466d9e8a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#b1f96fe9de8e2ee39159f748a8d33a4b">ucnv_setToUCallBack</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, UConverterToUCallback newAction, const void *newContext, UConverterToUCallback *oldAction, const void **oldContext, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the callback function used by the converter when an illegal or invalid sequence is found.  <a href="#b1f96fe9de8e2ee39159f748a8d33a4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#59fdaf2cf5dc57d738ed7a7657f6b03a">ucnv_setFromUCallBack</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, UConverterFromUCallback newAction, const void *newContext, UConverterFromUCallback *oldAction, const void **oldContext, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the current callback function used by the converter when an illegal or invalid sequence is found.  <a href="#59fdaf2cf5dc57d738ed7a7657f6b03a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f">ucnv_fromUnicode</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, char **target, const char *targetLimit, const UChar **source, const UChar *sourceLimit, int32_t *offsets, <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> flush, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an array of unicode characters to an array of codepage characters.  <a href="#4a1f09772549fbcd7dd782297212c19f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599">ucnv_toUnicode</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, UChar **target, const UChar *targetLimit, const char **source, const char *sourceLimit, int32_t *offsets, <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> flush, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a buffer of codepage bytes into an array of unicode UChars characters.  <a href="#fbea5eb35a5ec1517a548ffc868a5599"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#31bd5a5af440108a1a51bb0234ad32ac">ucnv_fromUChars</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, char *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the Unicode string into a codepage string using an existing UConverter.  <a href="#31bd5a5af440108a1a51bb0234ad32ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8">ucnv_toUChars</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, UChar *dest, int32_t destCapacity, const char *src, int32_t srcLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the codepage string into a Unicode string using an existing UConverter.  <a href="#1493c21231f237e6197c027229389ff8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6">ucnv_getNextUChar</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, const char **source, const char *sourceLimit, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a codepage buffer into Unicode one character at a time.  <a href="#af391b89870fd88b3da838eff1bd6ba6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6">ucnv_convertEx</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *targetCnv, <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *sourceCnv, char **target, const char *targetLimit, const char **source, const char *sourceLimit, UChar *pivotStart, UChar **pivotSource, UChar **pivotTarget, const UChar *pivotLimit, <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> reset, <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> flush, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from one external charset to another using two existing UConverters.  <a href="#f4c967c5afa207d064c24e19256586b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d">ucnv_convert</a> (const char *toConverterName, const char *fromConverterName, char *target, int32_t targetCapacity, const char *source, int32_t sourceLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from one external charset to another.  <a href="#2bdb6b1d3ac4069808348eb6961ce63d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#1b619c24f88f8b10f97b64ab1dc4fc86">ucnv_toAlgorithmic</a> (<a class="el" href="ucnv_8h.html#db0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a> algorithmicType, <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, char *target, int32_t targetCapacity, const char *source, int32_t sourceLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from one external charset to another.  <a href="#1b619c24f88f8b10f97b64ab1dc4fc86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#5cd24dc4d6c2fbec8c6481309459b7d5">ucnv_fromAlgorithmic</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="ucnv_8h.html#db0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a> algorithmicType, char *target, int32_t targetCapacity, const char *source, int32_t sourceLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from one external charset to another.  <a href="#5cd24dc4d6c2fbec8c6481309459b7d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#b0c427930c575dac20c0166ad4ef0986">ucnv_flushCache</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees up memory occupied by unused, cached converter shared data.  <a href="#b0c427930c575dac20c0166ad4ef0986"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#50a330a3628673c9a6a7eb6be30b94ae">ucnv_countAvailable</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of available converters, as per the alias file.  <a href="#50a330a3628673c9a6a7eb6be30b94ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#22feff7d04fe7a9dc62d1f7ecb4eb647">ucnv_getAvailableName</a> (int32_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the canonical converter name of the specified converter from a list of all available converters contaied in the alias file.  <a href="#22feff7d04fe7a9dc62d1f7ecb4eb647"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="uenum_8h.html#32b7253b2148022535be36a9fcdb5a8d">UEnumeration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#23282ab66962108aa8eba7096e4499ed">ucnv_openAllNames</a> (<a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a UEnumeration to enumerate all of the canonical converter names, as per the alias file, regardless of the ability to open each converter.  <a href="#23282ab66962108aa8eba7096e4499ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#b3db46e3d4319ea85ebfde031e2e1bcb">ucnv_countAliases</a> (const char *alias, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives the number of aliases for a given converter or alias name.  <a href="#b3db46e3d4319ea85ebfde031e2e1bcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#686d4e3d2905f3e2819577391fd08c2c">ucnv_getAlias</a> (const char *alias, uint16_t n, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives the name of the alias at given index of alias list.  <a href="#686d4e3d2905f3e2819577391fd08c2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#e16a53f19829be2f5227d0259e3120eb">ucnv_getAliases</a> (const char *alias, const char **aliases, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill-up the list of alias names for the given alias.  <a href="#e16a53f19829be2f5227d0259e3120eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="uenum_8h.html#32b7253b2148022535be36a9fcdb5a8d">UEnumeration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#b6901c3ca8e871ef1efaa14d7f653d40">ucnv_openStandardNames</a> (const char *convName, const char *standard, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a new UEnumeration object for enumerating all the alias names for a given converter that are recognized by a standard.  <a href="#b6901c3ca8e871ef1efaa14d7f653d40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#78bdc2c475baff8029a6a9782b862384">ucnv_countStandards</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives the number of standards associated to converter names.  <a href="#78bdc2c475baff8029a6a9782b862384"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#96c90729859689a2ae7c29f3f7f1306a">ucnv_getStandard</a> (uint16_t n, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives the name of the standard at given index of standard list.  <a href="#96c90729859689a2ae7c29f3f7f1306a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#2e1030c73ab423ec40b7b947320936c2">ucnv_getStandardName</a> (const char *name, const char *standard, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a standard name for a given converter name.  <a href="#2e1030c73ab423ec40b7b947320936c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#1601f0d125e4b695ad1f84d6db441e6e">ucnv_getCanonicalName</a> (const char *alias, const char *standard, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will return the internal canonical converter name of the tagged alias.  <a href="#1601f0d125e4b695ad1f84d6db441e6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#611d8da795489692511b07525a2f8b95">ucnv_getDefaultName</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current default converter name.  <a href="#611d8da795489692511b07525a2f8b95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#1a2aaa1bd664b8b53da8cb50f1025bf9">ucnv_setDefaultName</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is not thread safe.  <a href="#1a2aaa1bd664b8b53da8cb50f1025bf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#2962e5b30828db79345b5250cf411f90">ucnv_fixFileSeparator</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, UChar *source, int32_t sourceLen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fixes the backslash character mismapping.  <a href="#2962e5b30828db79345b5250cf411f90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#c38aa0a9daa58ca49dda17b2b7d40b8c">ucnv_isAmbiguous</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the converter contains ambiguous mappings of the same character or not.  <a href="#c38aa0a9daa58ca49dda17b2b7d40b8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#117c45b5c1d746c6f532f44985b686e4">ucnv_setFallback</a> (<a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> usesFallback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the converter to use fallback mappings or not.  <a href="#117c45b5c1d746c6f532f44985b686e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#036433918c08965c4c687892036db3eb">ucnv_usesFallback</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the converter uses fallback mappings or not.  <a href="#036433918c08965c4c687892036db3eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#d43176e199992be4069b67177ce6d3ce">ucnv_detectUnicodeSignature</a> (const char *source, int32_t sourceLength, int32_t *signatureLength, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detects Unicode signature byte sequences at the start of the byte stream and returns the charset name of the indicated Unicode charset.  <a href="#d43176e199992be4069b67177ce6d3ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#1d848a6a75fc14c38485ecd908694ac0">ucnv_fromUCountPending</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of UChars held in the converter's internal state because more input is needed for completing the conversion.  <a href="#1d848a6a75fc14c38485ecd908694ac0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#607e2305f45490a01fd8a32261e32e0c">ucnv_toUCountPending</a> (const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of chars held in the converter's internal state because more input is needed for completing the conversion.  <a href="#607e2305f45490a01fd8a32261e32e0c"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
C API: Character conversion. 
<p>
<h2>Character Conversion C API</h2>
<p>
This API is used to convert codepage or character encoded data to and from UTF-16. You can open a converter with <a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41">ucnv_open()</a>. With that converter, you can get its properties, set options, convert your data and close the converter.<p>
Since many software programs recogize different converter names for different types of converters, there are other functions in this API to iterate over the converter aliases. The functions <a class="el" href="ucnv_8h.html#22feff7d04fe7a9dc62d1f7ecb4eb647">ucnv_getAvailableName()</a>, <a class="el" href="ucnv_8h.html#686d4e3d2905f3e2819577391fd08c2c">ucnv_getAlias()</a> and <a class="el" href="ucnv_8h.html#2e1030c73ab423ec40b7b947320936c2">ucnv_getStandardName()</a> are some of the more frequently used alias functions to get this information.<p>
When a converter encounters an illegal, irregular, invalid or unmappable character its default behavior is to use a substitution character to replace the bad byte sequence. This behavior can be changed by using <a class="el" href="ucnv_8h.html#59fdaf2cf5dc57d738ed7a7657f6b03a">ucnv_setFromUCallBack()</a> or <a class="el" href="ucnv_8h.html#b1f96fe9de8e2ee39159f748a8d33a4b">ucnv_setToUCallBack()</a> on the converter. The header <a class="el" href="ucnv__err_8h.html" title="C UConverter predefined error callbacks.">ucnv_err.h</a> defines many other callback actions that can be used instead of a character substitution.<p>
More information about this API can be found in our <a href="http://icu-project.org/userguide/conversion.html">User's Guide</a>. 
<p>Definition in file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="b6ef5c3c7c83982313e415e697a26089"></a><!-- doxytag: member="ucnv.h::U_CNV_SAFECLONE_BUFFERSIZE" ref="b6ef5c3c7c83982313e415e697a26089" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define U_CNV_SAFECLONE_BUFFERSIZE&nbsp;&nbsp;&nbsp;1024          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Definition of a buffer size that is designed to be large enough for converters to be cloned with <a class="el" href="ucnv_8h.html#11a66c267dce12a78dac2690d983d69e" title="Thread safe converter cloning operation.">ucnv_safeClone()</a>. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000959">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00507">507</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a3d7e4ae84f8a95b9735ed3491cdb77e"></a><!-- doxytag: member="ucnv.h::UCNV_GET_MAX_BYTES_FOR_STRING" ref="a3d7e4ae84f8a95b9735ed3491cdb77e" args="(length, maxCharSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_GET_MAX_BYTES_FOR_STRING          </td>
          <td>(</td>
          <td class="paramtype">length,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">maxCharSize&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((int32_t)(length)+10)*(int32_t)(maxCharSize))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the size of a buffer for conversion from Unicode to a charset. 
<p>
The calculated size is guaranteed to be sufficient for this conversion.<p>
It takes into account initial and final non-character bytes that are output by some converters. It does not take into account callbacks which output more than one charset character sequence per call, like escape callbacks. The default (substitution) callback only outputs one charset character sequence.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Number of UChars to be converted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxCharSize</em>&nbsp;</td><td>Return value from <a class="el" href="ucnv_8h.html#11007a7bcc41b1030cda0ee28fe78195" title="Returns the maximum number of bytes that are output per UChar in conversion from...">ucnv_getMaxCharSize()</a> for the converter that will be used. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of a buffer that will be large enough to hold the output bytes of converting length UChars with the converter that returned the maxCharSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#11007a7bcc41b1030cda0ee28fe78195" title="Returns the maximum number of bytes that are output per UChar in conversion from...">ucnv_getMaxCharSize</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000970">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00744">744</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="867b3f44513565bca406eebe2f87ee99"></a><!-- doxytag: member="ucnv.h::UCNV_LOCALE_OPTION_STRING" ref="867b3f44513565bca406eebe2f87ee99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_LOCALE_OPTION_STRING&nbsp;&nbsp;&nbsp;&quot;,locale=&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converter option for specifying a locale. 
<p>
For example, ucnv_open("SCSU,locale=ja", &amp;errorCode); See convrtrs.txt.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000950">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00231">231</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3ab00bb423db8533da12c35848e4c281"></a><!-- doxytag: member="ucnv.h::UCNV_MAX_CONVERTER_NAME_LENGTH" ref="3ab00bb423db8533da12c35848e4c281" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_MAX_CONVERTER_NAME_LENGTH&nbsp;&nbsp;&nbsp;60          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum length of a converter name including the terminating NULL. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000938">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00075">75</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1a579f67d05b09f731df5a68eb80b851"></a><!-- doxytag: member="ucnv.h::UCNV_MAX_FULL_FILE_NAME_LENGTH" ref="1a579f67d05b09f731df5a68eb80b851" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_MAX_FULL_FILE_NAME_LENGTH&nbsp;&nbsp;&nbsp;(600+UCNV_MAX_CONVERTER_NAME_LENGTH)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum length of a converter name including path and terminating NULL. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000939">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00077">77</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="420028eb5f83222307bf16632857b148"></a><!-- doxytag: member="ucnv.h::UCNV_OPTION_SEP_CHAR" ref="420028eb5f83222307bf16632857b148" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_OPTION_SEP_CHAR&nbsp;&nbsp;&nbsp;','          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Character that separates converter names from options and options from each other. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000946">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00200">200</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8f221dc37208cc5c5e9b1d72a7103435"></a><!-- doxytag: member="ucnv.h::UCNV_OPTION_SEP_STRING" ref="8f221dc37208cc5c5e9b1d72a7103435" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_OPTION_SEP_STRING&nbsp;&nbsp;&nbsp;&quot;,&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String version of UCNV_OPTION_SEP_CHAR. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000947">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00207">207</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="082aba7f50746ff6135a4ca2a00f6d6c"></a><!-- doxytag: member="ucnv.h::UCNV_SI" ref="082aba7f50746ff6135a4ca2a00f6d6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_SI&nbsp;&nbsp;&nbsp;0x0F          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift in for EBDCDIC_STATEFUL and iso2022 states. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000940">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00080">80</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d3918524388c8100107273806bd58c65"></a><!-- doxytag: member="ucnv.h::UCNV_SO" ref="d3918524388c8100107273806bd58c65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_SO&nbsp;&nbsp;&nbsp;0x0E          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift out for EBDCDIC_STATEFUL and iso2022 states. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000941">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00082">82</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0588f7014923ad969821941f9dd51040"></a><!-- doxytag: member="ucnv.h::UCNV_SWAP_LFNL_OPTION_STRING" ref="0588f7014923ad969821941f9dd51040" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_SWAP_LFNL_OPTION_STRING&nbsp;&nbsp;&nbsp;&quot;,swaplfnl&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converter option for EBCDIC SBCS or mixed-SBCS/DBCS (stateful) codepages. 
<p>
Swaps Unicode mappings for EBCDIC LF and NL codes, as used on S/390 (z/OS) Unix System Services (Open Edition). For example, ucnv_open("ibm-1047,swaplfnl", &amp;errorCode); See convrtrs.txt.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000952">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00253">253</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="92803b44385721ec771befc01b5e8e3b"></a><!-- doxytag: member="ucnv.h::UCNV_VALUE_SEP_CHAR" ref="92803b44385721ec771befc01b5e8e3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_VALUE_SEP_CHAR&nbsp;&nbsp;&nbsp;'='          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Character that separates a converter option from its value. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000948">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00214">214</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="33cd53c804d95e14388398843e6edc82"></a><!-- doxytag: member="ucnv.h::UCNV_VALUE_SEP_STRING" ref="33cd53c804d95e14388398843e6edc82" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_VALUE_SEP_STRING&nbsp;&nbsp;&nbsp;&quot;=&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String version of UCNV_VALUE_SEP_CHAR. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000949">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00221">221</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c7b80fb72078403f8bdba322b63a5a93"></a><!-- doxytag: member="ucnv.h::UCNV_VERSION_OPTION_STRING" ref="c7b80fb72078403f8bdba322b63a5a93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_VERSION_OPTION_STRING&nbsp;&nbsp;&nbsp;&quot;,version=&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converter option for specifying a version selector (0. 
<p>
.9) for some converters. For example, ucnv_open("UTF-7,version=1", &amp;errorCode); See convrtrs.txt.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000951">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00241">241</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="dce3fef7c15d7c78196bf977ac96ec9c"></a><!-- doxytag: member="ucnv.h::USet" ref="dce3fef7c15d7c78196bf977ac96ec9c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="uset_8h.html#dce3fef7c15d7c78196bf977ac96ec9c">USet</a> <a class="el" href="uset_8h.html#dce3fef7c15d7c78196bf977ac96ec9c">USet</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable000937">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00066">66</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ba5ba7fbc2f113618ba57f4d9825ff85"></a><!-- doxytag: member="ucnv.h::UConverterPlatform" ref="ba5ba7fbc2f113618ba57f4d9825ff85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ucnv_8h.html#ba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum for specifying which platform a converter ID refers to. 
<p>
The use of platform/CCSID is not recommended. See <a class="el" href="ucnv_8h.html#9df0109e866c32078ab96fd2fe994b15" title="Creates a UConverter object from a CCSID number and platform pair.">ucnv_openCCSID()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#a14f20f0ffa7f602690956cf3a5c87e2" title="Gets a codepage platform associated with the converter.">ucnv_getPlatform</a> <p>
<a class="el" href="ucnv_8h.html#9df0109e866c32078ab96fd2fe994b15" title="Creates a UConverter object from a CCSID number and platform pair.">ucnv_openCCSID</a> <p>
<a class="el" href="ucnv_8h.html#0500738a0f4a552725725f9fe964e430" title="Gets a codepage number associated with the converter.">ucnv_getCCSID</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000943">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00141">141</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="db0b44c6bd828c9d4cc2defcbba0f902"></a><!-- doxytag: member="ucnv.h::UConverterType" ref="db0b44c6bd828c9d4cc2defcbba0f902" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ucnv_8h.html#db0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum for specifying basic types of converters. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#94a8af5dd3516cea50c2829e6c35b397" title="Gets the type of the converter e.g.">ucnv_getType</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000942">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00089">89</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="402221896b6d7153b14a5ff8dadde806"></a><!-- doxytag: member="ucnv.h::UConverterUnicodeSet" ref="402221896b6d7153b14a5ff8dadde806" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ucnv_8h.html#402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selectors for Unicode sets that can be returned by <a class="el" href="ucnv_8h.html#ec7c273c8ce917ff75224e25914c53be" title="Returns the set of Unicode code points that can be converted by an ICU converter...">ucnv_getUnicodeSet()</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#ec7c273c8ce917ff75224e25914c53be" title="Returns the set of Unicode code points that can be converted by an ICU converter...">ucnv_getUnicodeSet</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000978">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="402221896b6d7153b14a5ff8dadde806b08c09dd129a92d08725b5260b49cbf9"></a><!-- doxytag: member="UCNV_ROUNDTRIP_SET" ref="402221896b6d7153b14a5ff8dadde806b08c09dd129a92d08725b5260b49cbf9" args="" -->UCNV_ROUNDTRIP_SET</em>&nbsp;</td><td>
Select the set of roundtrippable Unicode code points. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable001014">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="402221896b6d7153b14a5ff8dadde80633cced69d47e6de3cbfd79d17f88fcaf"></a><!-- doxytag: member="UCNV_SET_COUNT" ref="402221896b6d7153b14a5ff8dadde80633cced69d47e6de3cbfd79d17f88fcaf" args="" -->UCNV_SET_COUNT</em>&nbsp;</td><td>
Number of UConverterUnicodeSet selectors. 
<p>
<dl compact><dt><b><a class="el" href="stable.html#_stable001015">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="ucnv_8h-source.html#l00870">870</a> of file <a class="el" href="ucnv_8h-source.html">ucnv.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="1718689bf60724fdfa08c51aa0cc5ea0"></a><!-- doxytag: member="ucnv.h::ucnv_close" ref="1718689bf60724fdfa08c51aa0cc5ea0" args="(UConverter *converter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the unicode converter and releases resources associated with just this instance. 
<p>
Does not free up shared converter tables.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the converter object to be deleted </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> <p>
<a class="el" href="ucnv_8h.html#82e86d5341b39c543c269c70b8310f3e" title="Creates a Unicode converter with the names specified as unicode string.">ucnv_openU</a> <p>
<a class="el" href="ucnv_8h.html#9df0109e866c32078ab96fd2fe994b15" title="Creates a UConverter object from a CCSID number and platform pair.">ucnv_openCCSID</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000960">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f998746d8a8a8afd837f04dbb1ab64a"></a><!-- doxytag: member="ucnv.h::ucnv_compareNames" ref="6f998746d8a8a8afd837f04dbb1ab64a" args="(const char *name1, const char *name2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ucnv_compareNames           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do a fuzzy compare of two converter/alias names. 
<p>
The comparison is case-insensitive, ignores leading zeroes if they are not followed by further digits, and ignores all but letters and digits. Thus the strings "UTF-8", "utf_8", "u*T@f08" and "Utf 8" are exactly equivalent. See section 1.4, Charset Alias Matching in Unicode Technical Standard #22 at <a href="http://www.unicode.org/reports/tr22/">http://www.unicode.org/reports/tr22/</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name1</em>&nbsp;</td><td>a converter name or alias, zero-terminated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name2</em>&nbsp;</td><td>a converter name or alias, zero-terminated </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the names match, or a negative value if the name1 lexically precedes name2, or a positive value if the name1 lexically follows name2. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000953">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="2bdb6b1d3ac4069808348eb6961ce63d"></a><!-- doxytag: member="ucnv.h::ucnv_convert" ref="2bdb6b1d3ac4069808348eb6961ce63d" args="(const char *toConverterName, const char *fromConverterName, char *target, int32_t targetCapacity, const char *source, int32_t sourceLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_convert           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>toConverterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fromConverterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>targetCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sourceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from one external charset to another. 
<p>
Internally, two converters are opened according to the name arguments, then the text is converted to and from the 16-bit Unicode "pivot" using <a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a>, then the converters are closed again.<p>
This is a convenience function, not an efficient way to convert a lot of text: <a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert()</a><ul>
<li>takes charset names, not converter objects, so that<ul>
<li>two converters are opened for each call</li><li>only single-string conversion is possible, not streaming operation</li></ul>
</li><li>does not provide enough information to find out, in case of failure, whether the toUnicode or the fromUnicode conversion failed</li><li>allows NUL-terminated input (only a single NUL byte, will not work for charsets with multi-byte NULs) (if sourceLength==-1, see parameters)</li><li>terminate with a NUL on output (only a single NUL byte, not useful for charsets with multi-byte NULs), or set U_STRING_NOT_TERMINATED_WARNING if the output exactly fills the target buffer</li><li>a pivot buffer is provided internally</li></ul>
<p>
The function returns when one of the following is true:<ul>
<li>the entire source text has been converted successfully to the target buffer and either the target buffer is terminated with a single NUL byte or the error code is set to U_STRING_NOT_TERMINATED_WARNING</li><li>a target buffer overflow occurred (U_BUFFER_OVERFLOW_ERROR) and the full output string length is returned ("preflighting")</li><li>a conversion error occurred (other <a class="el" href="utypes_8h.html#4d202200b6aa6f3c965ea370e0c8155f" title="Does the error code indicate a failure?">U_FAILURE()</a>, see description of pErrorCode)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>toConverterName</em>&nbsp;</td><td>The name of the converter that is used to convert from the UTF-16 pivot buffer to the target. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fromConverterName</em>&nbsp;</td><td>The name of the converter that is used to convert from the source to the UTF-16 pivot buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Pointer to the output buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targetCapacity</em>&nbsp;</td><td>Capacity of the target, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Pointer to the input buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLength</em>&nbsp;</td><td>Length of the input text, in bytes, or -1 for NUL-terminated input. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Length of the complete output text in bytes, even if it exceeds the targetCapacity and a U_BUFFER_OVERFLOW_ERROR is set.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx</a> <p>
<a class="el" href="ucnv_8h.html#5cd24dc4d6c2fbec8c6481309459b7d5" title="Convert from one external charset to another.">ucnv_fromAlgorithmic</a> <p>
<a class="el" href="ucnv_8h.html#1b619c24f88f8b10f97b64ab1dc4fc86" title="Convert from one external charset to another.">ucnv_toAlgorithmic</a> <p>
<a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode</a> <p>
<a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode</a> <p>
<a class="el" href="ucnv_8h.html#31bd5a5af440108a1a51bb0234ad32ac" title="Convert the Unicode string into a codepage string using an existing UConverter.">ucnv_fromUChars</a> <p>
<a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars</a> <p>
<a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6" title="Convert a codepage buffer into Unicode one character at a time.">ucnv_getNextUChar</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000990">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="f4c967c5afa207d064c24e19256586b6"></a><!-- doxytag: member="ucnv.h::ucnv_convertEx" ref="f4c967c5afa207d064c24e19256586b6" args="(UConverter *targetCnv, UConverter *sourceCnv, char **target, const char *targetLimit, const char **source, const char *sourceLimit, UChar *pivotStart, UChar **pivotSource, UChar **pivotTarget, const UChar *pivotLimit, UBool reset, UBool flush, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_convertEx           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>targetCnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>sourceCnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>targetLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>sourceLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>pivotStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar **&nbsp;</td>
          <td class="paramname"> <em>pivotSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar **&nbsp;</td>
          <td class="paramname"> <em>pivotTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>pivotLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>reset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from one external charset to another using two existing UConverters. 
<p>
Internally, two conversions - <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a> and <a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode()</a> - are used, "pivoting" through 16-bit Unicode.<p>
Important: For streaming conversion (multiple function calls for successive parts of a text stream), the caller must provide a pivot buffer explicitly, and must preserve the pivot buffer and associated pointers from one call to another. (The buffer may be moved if its contents and the relative pointer positions are preserved.)<p>
There is a similar function, <a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert()</a>, which has the following limitations:<ul>
<li>it takes charset names, not converter objects, so that<ul>
<li>two converters are opened for each call</li><li>only single-string conversion is possible, not streaming operation</li></ul>
</li><li>it does not provide enough information to find out, in case of failure, whether the toUnicode or the fromUnicode conversion failed</li></ul>
<p>
By contrast, <a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a><ul>
<li>takes UConverter parameters instead of charset names</li><li>fully exposes the pivot buffer for streaming conversion and complete error handling</li></ul>
<p>
<a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a> also provides further convenience:<ul>
<li>an option to reset the converters at the beginning (if reset==TRUE, see parameters; also sets *pivotTarget=*pivotSource=pivotStart)</li><li>allow NUL-terminated input (only a single NUL byte, will not work for charsets with multi-byte NULs) (if sourceLimit==NULL, see parameters)</li><li>terminate with a NUL on output (only a single NUL byte, not useful for charsets with multi-byte NULs), or set U_STRING_NOT_TERMINATED_WARNING if the output exactly fills the target buffer</li><li>the pivot buffer can be provided internally; possible only for whole-string conversion, not streaming conversion; in this case, the caller will not be able to get details about where an error occurred (if pivotStart==NULL, see below)</li></ul>
<p>
The function returns when one of the following is true:<ul>
<li>the entire source text has been converted successfully to the target buffer</li><li>a target buffer overflow occurred (U_BUFFER_OVERFLOW_ERROR)</li><li>a conversion error occurred (other <a class="el" href="utypes_8h.html#4d202200b6aa6f3c965ea370e0c8155f" title="Does the error code indicate a failure?">U_FAILURE()</a>, see description of pErrorCode)</li></ul>
<p>
Limitation compared to the direct use of <a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode()</a> and <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a>: <a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a> does not provide offset information.<p>
Limitation compared to <a class="el" href="ucnv_8h.html#31bd5a5af440108a1a51bb0234ad32ac" title="Convert the Unicode string into a codepage string using an existing UConverter.">ucnv_fromUChars()</a> and <a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars()</a>: <a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a> does not support preflighting directly.<p>
Sample code for converting a single string from one external charset to UTF-8, ignoring the location of errors:<p>
<div class="fragment"><pre class="fragment"> int32_t
 myToUTF8(<a class="code" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv,
          <span class="keyword">const</span> <span class="keywordtype">char</span> *s, int32_t length,
          <span class="keywordtype">char</span> *u8, int32_t capacity,
          <a class="code" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c" title="Error code to replace exception handling, so that the code is compatible with all...">UErrorCode</a> *pErrorCode) {
     <a class="code" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *utf8Cnv;
     <span class="keywordtype">char</span> *target;

     <span class="keywordflow">if</span>(<a class="code" href="utypes_8h.html#4d202200b6aa6f3c965ea370e0c8155f" title="Does the error code indicate a failure?">U_FAILURE</a>(*pErrorCode)) {
         <span class="keywordflow">return</span> 0;
     }

     utf8Cnv=myGetCachedUTF8Converter(pErrorCode);
     <span class="keywordflow">if</span>(<a class="code" href="utypes_8h.html#4d202200b6aa6f3c965ea370e0c8155f" title="Does the error code indicate a failure?">U_FAILURE</a>(*pErrorCode)) {
         <span class="keywordflow">return</span> 0;
     }

     <span class="keywordflow">if</span>(length&lt;0) {
         length=strlen(s);
     }
     target=u8;
     <a class="code" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx</a>(cnv, utf8Cnv,
                    &amp;target, u8+capacity,
                    &amp;s, s+length,
                    <a class="code" href="utypes_8h.html#070d2ce7b6bb7e5c05602aa8c308d0c4" title="Define NULL if necessary, to 0 for C++ and to ((void *)0) for C.">NULL</a>, <a class="code" href="utypes_8h.html#070d2ce7b6bb7e5c05602aa8c308d0c4" title="Define NULL if necessary, to 0 for C++ and to ((void *)0) for C.">NULL</a>, <a class="code" href="utypes_8h.html#070d2ce7b6bb7e5c05602aa8c308d0c4" title="Define NULL if necessary, to 0 for C++ and to ((void *)0) for C.">NULL</a>, <a class="code" href="utypes_8h.html#070d2ce7b6bb7e5c05602aa8c308d0c4" title="Define NULL if necessary, to 0 for C++ and to ((void *)0) for C.">NULL</a>,
                    <a class="code" href="umachine_8h.html#a8cecfc5c5c054d2875c03e77b7be15d" title="The TRUE value of a UBool.">TRUE</a>, <a class="code" href="umachine_8h.html#a8cecfc5c5c054d2875c03e77b7be15d" title="The TRUE value of a UBool.">TRUE</a>,
                    pErrorCode);
 
     myReleaseCachedUTF8Converter(utf8Cnv);

     <span class="comment">// return the output string length, but without preflighting</span>
     <span class="keywordflow">return</span> (int32_t)(target-u8);
 }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>targetCnv</em>&nbsp;</td><td>Output converter, used to convert from the UTF-16 pivot to the target using <a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceCnv</em>&nbsp;</td><td>Input converter, used to convert from the source to the UTF-16 pivot using <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>I/O parameter, same as for <a class="el" href="ucnv_8h.html#31bd5a5af440108a1a51bb0234ad32ac" title="Convert the Unicode string into a codepage string using an existing UConverter.">ucnv_fromUChars()</a>. Input: *target points to the beginning of the target buffer. Output: *target points to the first unit after the last char written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targetLimit</em>&nbsp;</td><td>Pointer to the first unit after the target buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>I/O parameter, same as for <a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars()</a>. Input: *source points to the beginning of the source buffer. Output: *source points to the first unit after the last char read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLimit</em>&nbsp;</td><td>Pointer to the first unit after the source buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pivotStart</em>&nbsp;</td><td>Pointer to the UTF-16 pivot buffer. If pivotStart==NULL, then an internal buffer is used and the other pivot arguments are ignored and can be NULL as well. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pivotSource</em>&nbsp;</td><td>I/O parameter, same as source in <a class="el" href="ucnv_8h.html#31bd5a5af440108a1a51bb0234ad32ac" title="Convert the Unicode string into a codepage string using an existing UConverter.">ucnv_fromUChars()</a> for conversion from the pivot buffer to the target buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pivotTarget</em>&nbsp;</td><td>I/O parameter, same as target in <a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars()</a> for conversion from the source buffer to the pivot buffer. It must be pivotStart&lt;=*pivotSource&lt;=*pivotTarget&lt;=pivotLimit and pivotStart&lt;pivotLimit (unless pivotStart==NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pivotLimit</em>&nbsp;</td><td>Pointer to the first unit after the pivot buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reset</em>&nbsp;</td><td>If TRUE, then ucnv_resetToUnicode(sourceCnv) and ucnv_resetFromUnicode(targetCnv) are called, and the pivot pointers are reset (*pivotTarget=*pivotSource=pivotStart). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flush</em>&nbsp;</td><td>If true, indicates the end of the input. Passed directly to <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a>, and carried over to <a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode()</a> when the source is empty as well. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. U_BUFFER_OVERFLOW_ERROR always refers to the target buffer because overflows into the pivot buffer are handled internally. Other conversion errors are from the source-to-pivot conversion if *pivotSource==pivotStart, otherwise from the pivot-to-target conversion.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert</a> <p>
<a class="el" href="ucnv_8h.html#5cd24dc4d6c2fbec8c6481309459b7d5" title="Convert from one external charset to another.">ucnv_fromAlgorithmic</a> <p>
<a class="el" href="ucnv_8h.html#1b619c24f88f8b10f97b64ab1dc4fc86" title="Convert from one external charset to another.">ucnv_toAlgorithmic</a> <p>
<a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode</a> <p>
<a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode</a> <p>
<a class="el" href="ucnv_8h.html#31bd5a5af440108a1a51bb0234ad32ac" title="Convert the Unicode string into a codepage string using an existing UConverter.">ucnv_fromUChars</a> <p>
<a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000989">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3db46e3d4319ea85ebfde031e2e1bcb"></a><!-- doxytag: member="ucnv.h::ucnv_countAliases" ref="b3db46e3d4319ea85ebfde031e2e1bcb" args="(const char *alias, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ucnv_countAliases           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gives the number of aliases for a given converter or alias name. 
<p>
If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING. This method only enumerates the listed entries in the alias file. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alias</em>&nbsp;</td><td>alias name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>error status </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of names on alias list for given alias </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000997">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="50a330a3628673c9a6a7eb6be30b94ae"></a><!-- doxytag: member="ucnv.h::ucnv_countAvailable" ref="50a330a3628673c9a6a7eb6be30b94ae" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_countAvailable           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of available converters, as per the alias file. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of available converters </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#22feff7d04fe7a9dc62d1f7ecb4eb647" title="Gets the canonical converter name of the specified converter from a list of all available...">ucnv_getAvailableName</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000994">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="78bdc2c475baff8029a6a9782b862384"></a><!-- doxytag: member="ucnv.h::ucnv_countStandards" ref="78bdc2c475baff8029a6a9782b862384" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ucnv_countStandards           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gives the number of standards associated to converter names. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of standards </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001001">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="d43176e199992be4069b67177ce6d3ce"></a><!-- doxytag: member="ucnv.h::ucnv_detectUnicodeSignature" ref="d43176e199992be4069b67177ce6d3ce" args="(const char *source, int32_t sourceLength, int32_t *signatureLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ucnv_detectUnicodeSignature           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sourceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>signatureLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detects Unicode signature byte sequences at the start of the byte stream and returns the charset name of the indicated Unicode charset. 
<p>
NULL is returned when no Unicode signature is recognized. The number of bytes in the signature is output as well.<p>
The caller can <a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open()</a> a converter using the charset name. The first code unit (UChar) from the start of the stream will be U+FEFF (the Unicode BOM/signature character) and can usually be ignored.<p>
For most Unicode charsets it is also possible to ignore the indicated number of initial stream bytes and start converting after them. However, there are stateful Unicode charsets (UTF-7 and BOCU-1) for which this will not work. Therefore, it is best to ignore the first output UChar instead of the input signature bytes. <p>
Usage: <div class="fragment"><pre class="fragment">      <a class="code" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c" title="Error code to replace exception handling, so that the code is compatible with all...">UErrorCode</a> err = <a class="code" href="utypes_8h.html#3343c1c8a8377277046774691c98d78ca43dbfc9499c5f911d04e1a0ca3bf6f9" title="No error, no warning.">U_ZERO_ERROR</a>;
      <span class="keywordtype">char</span> input[] = { <span class="stringliteral">'\xEF'</span>,<span class="stringliteral">'\xBB'</span>, <span class="stringliteral">'\xBF'</span>,<span class="stringliteral">'\x41'</span>,<span class="stringliteral">'\x42'</span>,<span class="stringliteral">'\x43'</span> };
      int32_t signatureLength = 0;
      <span class="keywordtype">char</span> *encoding = <a class="code" href="ucnv_8h.html#d43176e199992be4069b67177ce6d3ce" title="Detects Unicode signature byte sequences at the start of the byte stream and returns...">ucnv_detectUnicodeSignature</a>(input,<span class="keyword">sizeof</span>(input),&amp;signatureLength,&amp;err);
      <a class="code" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *conv = <a class="code" href="utypes_8h.html#070d2ce7b6bb7e5c05602aa8c308d0c4" title="Define NULL if necessary, to 0 for C++ and to ((void *)0) for C.">NULL</a>;
      <a class="code" href="umachine_8h.html#6bb9fad572d65b305324ef288165e2ac" title="Define UChar to be wchar_t if that is 16 bits wide; always assumed to be unsigned...">UChar</a> output[100];
      <a class="code" href="umachine_8h.html#6bb9fad572d65b305324ef288165e2ac" title="Define UChar to be wchar_t if that is 16 bits wide; always assumed to be unsigned...">UChar</a> *target = output, *out;
      <span class="keywordtype">char</span> *source = input;
      <span class="keywordflow">if</span>(encoding!=<a class="code" href="utypes_8h.html#070d2ce7b6bb7e5c05602aa8c308d0c4" title="Define NULL if necessary, to 0 for C++ and to ((void *)0) for C.">NULL</a> &amp;&amp; <a class="code" href="utypes_8h.html#527f2c69e6b2e3b2c53ad8a99fb36711" title="Does the error code indicate success?">U_SUCCESS</a>(err)){
          <span class="comment">// should signature be discarded ?</span>
          conv = <a class="code" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a>(encoding, &amp;err);
          <span class="comment">// do the conversion</span>
          <a class="code" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode</a>(conv,
                         target, output + <span class="keyword">sizeof</span>(output)/<a class="code" href="umachine_8h.html#949bcf5953a147ca7724397dfe230ee5" title="Number of bytes in a UChar.">U_SIZEOF_UCHAR</a>,
                         source, input + <span class="keyword">sizeof</span>(input),
                         <a class="code" href="utypes_8h.html#070d2ce7b6bb7e5c05602aa8c308d0c4" title="Define NULL if necessary, to 0 for C++ and to ((void *)0) for C.">NULL</a>, <a class="code" href="umachine_8h.html#a8cecfc5c5c054d2875c03e77b7be15d" title="The TRUE value of a UBool.">TRUE</a>, &amp;err);
          out = output;
          <span class="keywordflow">if</span> (discardSignature){
              ++out; <span class="comment">// ignore initial U+FEFF</span>
          }
          <span class="keywordflow">while</span>(out != target) {
              printf(<span class="stringliteral">"%04x "</span>, *out++);
          }
          puts(<span class="stringliteral">""</span>);
      }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source string in which the signature should be detected. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLength</em>&nbsp;</td><td>Length of the input string, or -1 if terminated with a NUL byte. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signatureLength</em>&nbsp;</td><td>A pointer to int32_t to receive the number of bytes that make up the signature of the detected UTF. 0 if not detected. Can be a NULL pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The name of the encoding detected. NULL if encoding is not detected. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001011">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div><p>
<a class="anchor" name="2962e5b30828db79345b5250cf411f90"></a><!-- doxytag: member="ucnv.h::ucnv_fixFileSeparator" ref="2962e5b30828db79345b5250cf411f90" args="(const UConverter *cnv, UChar *source, int32_t sourceLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_fixFileSeparator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sourceLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fixes the backslash character mismapping. 
<p>
For example, in SJIS, the backslash character in the ASCII portion is also used to represent the yen currency sign. When mapping from Unicode character 0x005C, it's unclear whether to map the character back to yen or backslash in SJIS. This function will take the input buffer and replace all the yen sign characters with backslash. This is necessary when the user tries to open a file with the input buffer on Windows. This function will test the converter to see whether such mapping is required. You can sometimes avoid using this function by using the correct version of Shift-JIS.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>The converter representing the target codepage. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>the input buffer to be fixed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLen</em>&nbsp;</td><td>the length of the input buffer </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#c38aa0a9daa58ca49dda17b2b7d40b8c" title="Determines if the converter contains ambiguous mappings of the same character or...">ucnv_isAmbiguous</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001007">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b0c427930c575dac20c0166ad4ef0986"></a><!-- doxytag: member="ucnv.h::ucnv_flushCache" ref="b0c427930c575dac20c0166ad4ef0986" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_flushCache           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees up memory occupied by unused, cached converter shared data. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of cached converters successfully deleted </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#1718689bf60724fdfa08c51aa0cc5ea0" title="Deletes the unicode converter and releases resources associated with just this instance...">ucnv_close</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000993">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="5cd24dc4d6c2fbec8c6481309459b7d5"></a><!-- doxytag: member="ucnv.h::ucnv_fromAlgorithmic" ref="5cd24dc4d6c2fbec8c6481309459b7d5" args="(UConverter *cnv, UConverterType algorithmicType, char *target, int32_t targetCapacity, const char *source, int32_t sourceLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_fromAlgorithmic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#db0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a>&nbsp;</td>
          <td class="paramname"> <em>algorithmicType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>targetCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sourceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from one external charset to another. 
<p>
Internally, the text is converted to and from the 16-bit Unicode "pivot" using <a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a>. <a class="el" href="ucnv_8h.html#5cd24dc4d6c2fbec8c6481309459b7d5" title="Convert from one external charset to another.">ucnv_fromAlgorithmic()</a> works exactly like <a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert()</a> except that the two converters need not be looked up and opened completely.<p>
The source-to-pivot conversion uses a purely algorithmic converter according to the specified type, e.g., UCNV_UTF8 for a UTF-8 converter. The pivot-to-target conversion uses the cnv converter parameter.<p>
Internally, the algorithmic converter is opened and closed for each function call, which is more efficient than using the public <a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open()</a> but somewhat less efficient than only resetting an existing converter and using <a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a>.<p>
This function is more convenient than <a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a> for single-string conversions, especially when "preflighting" is desired (returning the length of the complete output even if it does not fit into the target buffer; see the User Guide Strings chapter). See <a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert()</a> for details.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>The converter that is used to convert from the UTF-16 pivot buffer to the target. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>algorithmicType</em>&nbsp;</td><td>UConverterType constant identifying the desired source charset as a purely algorithmic converter. Those are converters for Unicode charsets like UTF-8, BOCU-1, SCSU, UTF-7, IMAP-mailbox-name, etc., as well as US-ASCII and ISO-8859-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Pointer to the output buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targetCapacity</em>&nbsp;</td><td>Capacity of the target, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Pointer to the input buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLength</em>&nbsp;</td><td>Length of the input text, in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Length of the complete output text in bytes, even if it exceeds the targetCapacity and a U_BUFFER_OVERFLOW_ERROR is set.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#5cd24dc4d6c2fbec8c6481309459b7d5" title="Convert from one external charset to another.">ucnv_fromAlgorithmic</a> <p>
<a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert</a> <p>
<a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx</a> <p>
<a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode</a> <p>
<a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode</a> <p>
<a class="el" href="ucnv_8h.html#31bd5a5af440108a1a51bb0234ad32ac" title="Convert the Unicode string into a codepage string using an existing UConverter.">ucnv_fromUChars</a> <p>
<a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000992">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="31bd5a5af440108a1a51bb0234ad32ac"></a><!-- doxytag: member="ucnv.h::ucnv_fromUChars" ref="31bd5a5af440108a1a51bb0234ad32ac" args="(UConverter *cnv, char *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_fromUChars           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the Unicode string into a codepage string using an existing UConverter. 
<p>
The output string is NUL-terminated if possible.<p>
This function is a more convenient but less powerful version of <a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode()</a>. It is only useful for whole strings, not for streaming conversion.<p>
The maximum output buffer capacity required (barring output from callbacks) will be UCNV_GET_MAX_BYTES_FOR_STRING(srcLength, ucnv_getMaxCharSize(cnv)).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>the converter object to be used (<a class="el" href="ucnv_8h.html#ba8147239dca1fe5773de4905f2f74c2" title="Resets the from-Unicode part of a converter state to the default state.">ucnv_resetFromUnicode()</a> will be called) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the input Unicode string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>the input string length, or -1 if NUL-terminated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination string buffer, can be NULL if destCapacity==0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>the number of chars available at dest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>normal ICU error code; common error codes that may be set by this function include U_BUFFER_OVERFLOW_ERROR, U_STRING_NOT_TERMINATED_WARNING, U_ILLEGAL_ARGUMENT_ERROR, and conversion errors </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the length of the output string, not counting the terminating NUL; if the length is greater than destCapacity, then the string will not fit and a buffer of the indicated length would need to be passed in </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode</a> <p>
<a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert</a> <p>
<a class="el" href="ucnv_8h.html#a3d7e4ae84f8a95b9735ed3491cdb77e" title="Calculates the size of a buffer for conversion from Unicode to a charset.">UCNV_GET_MAX_BYTES_FOR_STRING</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000986">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1d848a6a75fc14c38485ecd908694ac0"></a><!-- doxytag: member="ucnv.h::ucnv_fromUCountPending" ref="1d848a6a75fc14c38485ecd908694ac0" args="(const UConverter *cnv, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_fromUCountPending           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of UChars held in the converter's internal state because more input is needed for completing the conversion. 
<p>
This function is useful for mapping semantics of ICU's converter interface to those of iconv, and this information is not needed for normal conversion. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>The converter in which the input is held </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of UChars in the state. -1 if an error is encountered. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001012">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div><p>
<a class="anchor" name="4a1f09772549fbcd7dd782297212c19f"></a><!-- doxytag: member="ucnv.h::ucnv_fromUnicode" ref="4a1f09772549fbcd7dd782297212c19f" args="(UConverter *converter, char **target, const char *targetLimit, const UChar **source, const UChar *sourceLimit, int32_t *offsets, UBool flush, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_fromUnicode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>targetLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar **&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>sourceLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts an array of unicode characters to an array of codepage characters. 
<p>
This function is optimized for converting a continuous stream of data in buffer-sized chunks, where the entire source and target does not fit in available buffers.<p>
The source pointer is an in/out parameter. It starts out pointing where the conversion is to begin, and ends up pointing after the last UChar consumed.<p>
Target similarly starts out pointer at the first available byte in the output buffer, and ends up pointing after the last byte written to the output.<p>
The converter always attempts to consume the entire source buffer, unless (1.) the target buffer is full, or (2.) a failing error is returned from the current callback function. When a successful error status has been returned, it means that all of the source buffer has been consumed. At that point, the caller should reset the source and sourceLimit pointers to point to the next chunk.<p>
At the end of the stream (flush==TRUE), the input is completely consumed when *source==sourceLimit and no error code is set. The converter object is then automatically reset by this function. (This means that a converter need not be reset explicitly between data streams if it finishes the previous stream without errors.)<p>
This is a <em>stateful</em> conversion. Additionally, even when all source data has been consumed, some data may be in the converters' internal state. Call this function repeatedly, updating the target pointers with the next empty chunk of target in case of a <code>U_BUFFER_OVERFLOW_ERROR</code>, and updating the source pointers with the next chunk of source when a successful error status is returned, until there are no more chunks of source data. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>I/O parameter. Input : Points to the beginning of the buffer to copy codepage characters to. Output : points to after the last codepage character copied to <code>target</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targetLimit</em>&nbsp;</td><td>the pointer just after last of the <code>target</code> buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>I/O parameter, pointer to pointer to the source Unicode character buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLimit</em>&nbsp;</td><td>the pointer just after the last of the source buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offsets</em>&nbsp;</td><td>if NULL is passed, nothing will happen to it, otherwise it needs to have the same number of allocated cells as <code>target</code>. Will fill in offsets from target to source pointer e.g: <code>offsets[3]</code> is equal to 6, it means that the <code>target[3]</code> was a result of transcoding <code>source[6]</code> For output data carried across calls, and other data without a specific source character (such as from escape sequences or callbacks) -1 will be placed for offsets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flush</em>&nbsp;</td><td>set to <code>TRUE</code> if the current source buffer is the last available chunk of the source, <code>FALSE</code> otherwise. Note that if a failing status is returned, this function may have to be called multiple times with flush set to <code>TRUE</code> until the source buffer is consumed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>the error status. <code>U_ILLEGAL_ARGUMENT_ERROR</code> will be set if the converter is <code>NULL</code>. <code>U_BUFFER_OVERFLOW_ERROR</code> will be set if the target is full and there is still data to be written to the target. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#31bd5a5af440108a1a51bb0234ad32ac" title="Convert the Unicode string into a codepage string using an existing UConverter.">ucnv_fromUChars</a> <p>
<a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert</a> <p>
<a class="el" href="ucnv_8h.html#12edd465a611c41e418632f5d5f2dbe4" title="Returns the minimum byte length for characters in this codepage.">ucnv_getMinCharSize</a> <p>
<a class="el" href="ucnv_8h.html#b1f96fe9de8e2ee39159f748a8d33a4b" title="Changes the callback function used by the converter when an illegal or invalid sequence...">ucnv_setToUCallBack</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000984">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="686d4e3d2905f3e2819577391fd08c2c"></a><!-- doxytag: member="ucnv.h::ucnv_getAlias" ref="686d4e3d2905f3e2819577391fd08c2c" args="(const char *alias, uint16_t n, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ucnv_getAlias           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gives the name of the alias at given index of alias list. 
<p>
This method only enumerates the listed entries in the alias file. If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alias</em>&nbsp;</td><td>alias name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>index in alias list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>result of operation </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the name of the alias at given index </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#b3db46e3d4319ea85ebfde031e2e1bcb" title="Gives the number of aliases for a given converter or alias name.">ucnv_countAliases</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000998">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="e16a53f19829be2f5227d0259e3120eb"></a><!-- doxytag: member="ucnv.h::ucnv_getAliases" ref="e16a53f19829be2f5227d0259e3120eb" args="(const char *alias, const char **aliases, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_getAliases           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>aliases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill-up the list of alias names for the given alias. 
<p>
This method only enumerates the listed entries in the alias file. If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alias</em>&nbsp;</td><td>alias name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aliases</em>&nbsp;</td><td>fill-in list, aliases is a pointer to an array of <code><a class="el" href="ucnv_8h.html#b3db46e3d4319ea85ebfde031e2e1bcb" title="Gives the number of aliases for a given converter or alias name.">ucnv_countAliases()</a></code> string-pointers (<code>const char *</code>) that will be filled in. The strings themselves are owned by the library. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>result of operation </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000999">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="22feff7d04fe7a9dc62d1f7ecb4eb647"></a><!-- doxytag: member="ucnv.h::ucnv_getAvailableName" ref="22feff7d04fe7a9dc62d1f7ecb4eb647" args="(int32_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ucnv_getAvailableName           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the canonical converter name of the specified converter from a list of all available converters contaied in the alias file. 
<p>
All converters in this list can be opened.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>the index to a converter available on the system (in the range <code>[0..ucnv_countAvaiable()]</code>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer a string (library owned), or <code>NULL</code> if the index is out of bounds. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#50a330a3628673c9a6a7eb6be30b94ae" title="Returns the number of available converters, as per the alias file.">ucnv_countAvailable</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000995">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1601f0d125e4b695ad1f84d6db441e6e"></a><!-- doxytag: member="ucnv.h::ucnv_getCanonicalName" ref="1601f0d125e4b695ad1f84d6db441e6e" args="(const char *alias, const char *standard, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ucnv_getCanonicalName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>standard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will return the internal canonical converter name of the tagged alias. 
<p>
This is the opposite of ucnv_openStandardNames, which returns the tagged alias given the canonical name. <p>
Example alias table:<br>
 conv alias1 { STANDARD1 } alias2 { STANDARD1* } <p>
Result of ucnv_getStandardName("alias1", "STANDARD1") from example alias table:<br>
 <b>"conv"</b><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the canonical converter name; if a standard or alias name cannot be determined, then <code>NULL</code> is returned. The returned string is owned by the library. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#2e1030c73ab423ec40b7b947320936c2" title="Returns a standard name for a given converter name.">ucnv_getStandardName</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001004">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div><p>
<a class="anchor" name="0500738a0f4a552725725f9fe964e430"></a><!-- doxytag: member="ucnv.h::ucnv_getCCSID" ref="0500738a0f4a552725725f9fe964e430" args="(const UConverter *converter, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_getCCSID           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a codepage number associated with the converter. 
<p>
This is not guaranteed to be the one used to create the converter. Some converters do not represent platform registered codepages and return zero for the codepage number. The error code fill-in parameter indicates if the codepage number is available. Does not check if the converter is <code>NULL</code> or if converter's data table is <code>NULL</code>.<p>
Important: The use of CCSIDs is not recommended because it is limited to only two platforms in principle and only one (UCNV_IBM) in the current ICU converter API. Also, CCSIDs are insufficient to identify IBM Unicode conversion tables precisely. For more details see <a class="el" href="ucnv_8h.html#9df0109e866c32078ab96fd2fe994b15" title="Creates a UConverter object from a CCSID number and platform pair.">ucnv_openCCSID()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>the error status code. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If any error occurrs, -1 will be returned otherwise, the codepage number will be returned </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#9df0109e866c32078ab96fd2fe994b15" title="Creates a UConverter object from a CCSID number and platform pair.">ucnv_openCCSID</a> <p>
<a class="el" href="ucnv_8h.html#a14f20f0ffa7f602690956cf3a5c87e2" title="Gets a codepage platform associated with the converter.">ucnv_getPlatform</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000974">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="611d8da795489692511b07525a2f8b95"></a><!-- doxytag: member="ucnv.h::ucnv_getDefaultName" ref="611d8da795489692511b07525a2f8b95" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ucnv_getDefaultName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current default converter name. 
<p>
If you want to open a default converter, you do not need to use this function. It is faster if you pass a NULL argument to ucnv_open the default converter.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the current default converter name. Storage owned by the library </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#1a2aaa1bd664b8b53da8cb50f1025bf9" title="This function is not thread safe.">ucnv_setDefaultName</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001005">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="36c33bb6459c126f64e5472c6e5023a6"></a><!-- doxytag: member="ucnv.h::ucnv_getDisplayName" ref="36c33bb6459c126f64e5472c6e5023a6" args="(const UConverter *converter, const char *displayLocale, UChar *displayName, int32_t displayNameCapacity, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_getDisplayName           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>displayLocale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>displayName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>displayNameCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the display name of the converter passed in based on the <a class="el" href="classLocale.html" title="A Locale object represents a specific geographical, political, or cultural region...">Locale</a> passed in. 
<p>
If the locale contains no display name, the internal ASCII name will be filled in.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>displayLocale</em>&nbsp;</td><td>is the specific <a class="el" href="classLocale.html" title="A Locale object represents a specific geographical, political, or cultural region...">Locale</a> we want to localised for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>displayName</em>&nbsp;</td><td>user provided buffer to be filled in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>displayNameCapacity</em>&nbsp;</td><td>size of displayName Buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>error status code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>displayNameLength number of UChar needed in displayName </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#ac2e332117c919a01516c726c051dd55" title="Gets the internal, canonical name of the converter (zero-terminated).">ucnv_getName</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000972">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a2dcbf10e3b08a97ed0b06466d9e8a5"></a><!-- doxytag: member="ucnv.h::ucnv_getFromUCallBack" ref="2a2dcbf10e3b08a97ed0b06466d9e8a5" args="(const UConverter *converter, UConverterFromUCallback *action, const void **context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_getFromUCallBack           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UConverterFromUCallback *&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current callback function used by the converter when illegal or invalid Unicode sequence is found. 
<p>
Context pointers are always owned by the caller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>fillin: returns the callback function pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>fillin: returns the callback's private void* context </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#59fdaf2cf5dc57d738ed7a7657f6b03a" title="Changes the current callback function used by the converter when an illegal or invalid...">ucnv_setFromUCallBack</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000981">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="e8c925ce8f47ab08c53f9e3b3b9664f4"></a><!-- doxytag: member="ucnv.h::ucnv_getInvalidChars" ref="e8c925ce8f47ab08c53f9e3b3b9664f4" args="(const UConverter *converter, char *errBytes, int8_t *len, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_getInvalidChars           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>errBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills in the output parameter, errBytes, with the error characters from the last failing conversion. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errBytes</em>&nbsp;</td><td>the codepage bytes which were in error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>on input the capacity of errBytes, on output the number of bytes which were copied to it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>the error status code. If the substitution character array is too small, an <code>U_INDEX_OUTOFBOUNDS_ERROR</code> will be returned. </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000964">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="341f4716c12e62d24cc8431eb9dfecdd"></a><!-- doxytag: member="ucnv.h::ucnv_getInvalidUChars" ref="341f4716c12e62d24cc8431eb9dfecdd" args="(const UConverter *converter, UChar *errUChars, int8_t *len, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_getInvalidUChars           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>errUChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills in the output parameter, errChars, with the error characters from the last failing conversion. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errUChars</em>&nbsp;</td><td>the UChars which were in error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>on input the capacity of errUChars, on output the number of UChars which were copied to it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>the error status code. If the substitution character array is too small, an <code>U_INDEX_OUTOFBOUNDS_ERROR</code> will be returned. </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000965">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="11007a7bcc41b1030cda0ee28fe78195"></a><!-- doxytag: member="ucnv.h::ucnv_getMaxCharSize" ref="11007a7bcc41b1030cda0ee28fe78195" args="(const UConverter *converter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t ucnv_getMaxCharSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the maximum number of bytes that are output per UChar in conversion from Unicode using this converter. 
<p>
The returned number can be used with UCNV_GET_MAX_BYTES_FOR_STRING to calculate the size of a target buffer for conversion from Unicode.<p>
Note: Before ICU 2.8, this function did not return reliable numbers for some stateful converters (EBCDIC_STATEFUL, ISO-2022) and LMBCS.<p>
This number may not be the same as the maximum number of bytes per "conversion unit". In other words, it may not be the intuitively expected number of bytes per character that would be published for a charset, and may not fulfill any other purpose than the allocation of an output buffer of guaranteed sufficient size for a given input length and converter.<p>
Examples for special cases that are taken into account:<ul>
<li>Supplementary code points may convert to more bytes than BMP code points. This function returns bytes per UChar (UTF-16 code unit), not per Unicode code point, for efficient buffer allocation.</li><li>State-shifting output (SI/SO, escapes, etc.) from stateful converters.</li><li>When m input UChars are converted to n output bytes, then the maximum m/n is taken into account.</li></ul>
<p>
The number returned here does not take into account (see UCNV_GET_MAX_BYTES_FOR_STRING):<ul>
<li>callbacks which output more than one charset character sequence per call, like escape callbacks</li><li>initial and final non-character bytes that are output by some converters (automatic BOMs, initial escape sequence, final SI, etc.)</li></ul>
<p>
Examples for returned values:<ul>
<li>SBCS charsets: 1</li><li>Shift-JIS: 2</li><li>UTF-16: 2 (2 per BMP, 4 per surrogate _pair_, BOM not counted)</li><li>UTF-8: 3 (3 per BMP, 4 per surrogate _pair_)</li><li>EBCDIC_STATEFUL (EBCDIC mixed SBCS/DBCS): 3 (SO + DBCS)</li><li>ISO-2022: 3 (always outputs UTF-8)</li><li>ISO-2022-JP: 6 (4-byte escape sequences + DBCS)</li><li>ISO-2022-CN: 8 (4-byte designator sequences + 2-byte SS2/SS3 + DBCS)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>The Unicode converter. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The maximum number of bytes per UChar that are output by <a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode()</a>, to be used together with UCNV_GET_MAX_BYTES_FOR_STRING for buffer allocation.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#a3d7e4ae84f8a95b9735ed3491cdb77e" title="Calculates the size of a buffer for conversion from Unicode to a charset.">UCNV_GET_MAX_BYTES_FOR_STRING</a> <p>
<a class="el" href="ucnv_8h.html#12edd465a611c41e418632f5d5f2dbe4" title="Returns the minimum byte length for characters in this codepage.">ucnv_getMinCharSize</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000969">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="12edd465a611c41e418632f5d5f2dbe4"></a><!-- doxytag: member="ucnv.h::ucnv_getMinCharSize" ref="12edd465a611c41e418632f5d5f2dbe4" args="(const UConverter *converter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t ucnv_getMinCharSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the minimum byte length for characters in this codepage. 
<p>
This is usually either 1 or 2. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the minimum number of bytes allowed by this particular converter </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#11007a7bcc41b1030cda0ee28fe78195" title="Returns the maximum number of bytes that are output per UChar in conversion from...">ucnv_getMaxCharSize</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000971">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac2e332117c919a01516c726c051dd55"></a><!-- doxytag: member="ucnv.h::ucnv_getName" ref="ac2e332117c919a01516c726c051dd55" args="(const UConverter *converter, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ucnv_getName           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the internal, canonical name of the converter (zero-terminated). 
<p>
The lifetime of the returned string will be that of the converter passed to this function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>UErrorCode status </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the internal name of the converter </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#36c33bb6459c126f64e5472c6e5023a6" title="Returns the display name of the converter passed in based on the Locale passed in...">ucnv_getDisplayName</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000973">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="af391b89870fd88b3da838eff1bd6ba6"></a><!-- doxytag: member="ucnv.h::ucnv_getNextUChar" ref="af391b89870fd88b3da838eff1bd6ba6" args="(UConverter *converter, const char **source, const char *sourceLimit, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> ucnv_getNextUChar           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>sourceLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a codepage buffer into Unicode one character at a time. 
<p>
The input is completely consumed when the U_INDEX_OUTOFBOUNDS_ERROR is set.<p>
Advantage compared to <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a> or <a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars()</a>:<ul>
<li>Faster for small amounts of data, for most converters, e.g., US-ASCII, ISO-8859-1, UTF-8/16/32, and most "normal" charsets. (For complex converters, e.g., SCSU, UTF-7 and ISO 2022 variants, it uses <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a> internally.)</li><li>Convenient.</li></ul>
<p>
Limitations compared to <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a>:<ul>
<li>Always assumes flush=TRUE. This makes <a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6" title="Convert a codepage buffer into Unicode one character at a time.">ucnv_getNextUChar()</a> unsuitable for "streaming" conversion, that is, for where the input is supplied in multiple buffers, because <a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6" title="Convert a codepage buffer into Unicode one character at a time.">ucnv_getNextUChar()</a> will assume the end of the input at the end of the first buffer.</li><li>Does not provide offset output.</li></ul>
<p>
It is possible to "mix" <a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6" title="Convert a codepage buffer into Unicode one character at a time.">ucnv_getNextUChar()</a> and <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a> because <a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6" title="Convert a codepage buffer into Unicode one character at a time.">ucnv_getNextUChar()</a> uses the current state of the converter (unlike <a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars()</a> which always resets first). However, if <a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6" title="Convert a codepage buffer into Unicode one character at a time.">ucnv_getNextUChar()</a> is called after <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a> stopped in the middle of a character sequence (with flush=FALSE), then <a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6" title="Convert a codepage buffer into Unicode one character at a time.">ucnv_getNextUChar()</a> will always use the slower <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a> internally until the next character boundary. (This is new in ICU 2.6. In earlier releases, <a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6" title="Convert a codepage buffer into Unicode one character at a time.">ucnv_getNextUChar()</a> had to start at a character boundary.)<p>
Instead of using <a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6" title="Convert a codepage buffer into Unicode one character at a time.">ucnv_getNextUChar()</a>, it is recommended to convert using <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a> or <a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars()</a> and then iterate over the text using <a class="el" href="utf16_8h.html#844bb48486904fdca40c8b883e9c80ee" title="Get a code point from a string at a code point boundary offset, and advance the offset...">U16_NEXT()</a> or a <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a> (<a class="el" href="uiter_8h.html" title="C API: Unicode Character Iteration.">uiter.h</a>) or a C++ <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> or similar. This allows streaming conversion and offset output, for example.<p>
Handling of surrogate pairs and supplementary-plane code points:<br>
 There are two different kinds of codepages that provide mappings for surrogate characters: <ul>
<li>
Codepages like UTF-8, UTF-32, and GB 18030 provide direct representations for Unicode code points U+10000-U+10ffff as well as for single surrogates U+d800-U+dfff. Each valid sequence will result in exactly one returned code point. If a sequence results in a single surrogate, then that will be returned by itself, even if a neighboring sequence encodes the matching surrogate. </li>
<li>
Codepages like SCSU and LMBCS (and UTF-16) provide direct representations only for BMP code points including surrogates. Code points in supplementary planes are represented with two sequences, each encoding a surrogate. For these codepages, matching pairs of surrogates will be combined into single code points for returning from this function. (Note that SCSU is actually a mix of these codepage types.) </li>
</ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>an open UConverter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>the address of a pointer to the codepage buffer, will be updated to point after the bytes consumed in the conversion call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLimit</em>&nbsp;</td><td>points to the end of the input buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>fills in error status (see ucnv_toUnicode) <code>U_INDEX_OUTOFBOUNDS_ERROR</code> will be set if the input is empty or does not convert to any output (e.g.: pure state-change codes SI/SO, escape sequences for ISO 2022, or if the callback did not output anything, ...). This function will not set a <code>U_BUFFER_OVERFLOW_ERROR</code> because the "buffer" is the return code. However, there might be subsequent output stored in the converter object that will be returned in following calls to this function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a UChar32 resulting from the partial conversion of source </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode</a> <p>
<a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars</a> <p>
<a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000988">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="a14f20f0ffa7f602690956cf3a5c87e2"></a><!-- doxytag: member="ucnv.h::ucnv_getPlatform" ref="a14f20f0ffa7f602690956cf3a5c87e2" args="(const UConverter *converter, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucnv_8h.html#ba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a> ucnv_getPlatform           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a codepage platform associated with the converter. 
<p>
Currently, only <code>UCNV_IBM</code> will be returned. Does not test if the converter is <code>NULL</code> or if converter's data table is <code>NULL</code>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>the error status code. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The codepage platform </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000975">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="96c90729859689a2ae7c29f3f7f1306a"></a><!-- doxytag: member="ucnv.h::ucnv_getStandard" ref="96c90729859689a2ae7c29f3f7f1306a" args="(uint16_t n, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ucnv_getStandard           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gives the name of the standard at given index of standard list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>index in standard list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>result of operation </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the name of the standard at given index. Owned by the library. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001002">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e1030c73ab423ec40b7b947320936c2"></a><!-- doxytag: member="ucnv.h::ucnv_getStandardName" ref="2e1030c73ab423ec40b7b947320936c2" args="(const char *name, const char *standard, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ucnv_getStandardName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>standard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a standard name for a given converter name. 
<p>
Example alias table:<br>
 conv alias1 { STANDARD1 } alias2 { STANDARD1* } <p>
Result of ucnv_getStandardName("conv", "STANDARD1") from example alias table:<br>
 <b>"alias2"</b><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>original converter name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>standard</em>&nbsp;</td><td>name of the standard governing the names; MIME and IANA are such standards </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>result of operation </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the standard converter name; if a standard converter name cannot be determined, then <code>NULL</code> is returned. Owned by the library. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001003">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="a970dda00a55c1751b7fe0bb34b04015"></a><!-- doxytag: member="ucnv.h::ucnv_getStarters" ref="a970dda00a55c1751b7fe0bb34b04015" args="(const UConverter *converter, UBool starters[256], UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_getStarters           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>starters</em>[256], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the "starter" (lead) bytes for converters of type MBCS. 
<p>
Will fill in an <code>U_ILLEGAL_ARGUMENT_ERROR</code> if converter passed in is not MBCS. Fills in an array of type UBool, with the value of the byte as offset to the array. For example, if (starters[0x20] == TRUE) at return, it means that the byte 0x20 is a starter byte in this converter. Context pointers are always owned by the caller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>a valid, opened converter of type MBCS </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>starters</em>&nbsp;</td><td>an array of size 256 to be filled in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>error status, <code>U_ILLEGAL_ARGUMENT_ERROR</code> if the converter is not a type which can return starters. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#94a8af5dd3516cea50c2829e6c35b397" title="Gets the type of the converter e.g.">ucnv_getType</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000977">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="118a87477ffa827d00dd50727da02e31"></a><!-- doxytag: member="ucnv.h::ucnv_getSubstChars" ref="118a87477ffa827d00dd50727da02e31" args="(const UConverter *converter, char *subChars, int8_t *len, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_getSubstChars           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>subChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills in the output parameter, subChars, with the substitution characters as multiple bytes. 
<p>
If <a class="el" href="ucnv_8h.html#f87333c550d699794ab84151ed9007c6" title="Set a substitution string for converting from Unicode to a charset.">ucnv_setSubstString()</a> set a Unicode string because the converter is stateful, then subChars will be an empty string.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subChars</em>&nbsp;</td><td>the subsitution characters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>on input the capacity of subChars, on output the number of bytes copied to it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>the outgoing error status code. If the substitution character array is too small, an <code>U_INDEX_OUTOFBOUNDS_ERROR</code> will be returned. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#f87333c550d699794ab84151ed9007c6" title="Set a substitution string for converting from Unicode to a charset.">ucnv_setSubstString</a> <p>
<a class="el" href="ucnv_8h.html#c160b1b44ac9b5124ec083810709603a" title="Sets the substitution chars when converting from unicode to a codepage.">ucnv_setSubstChars</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000961">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="f45faec39053767f4a7a779586c24223"></a><!-- doxytag: member="ucnv.h::ucnv_getToUCallBack" ref="f45faec39053767f4a7a779586c24223" args="(const UConverter *converter, UConverterToUCallback *action, const void **context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_getToUCallBack           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UConverterToUCallback *&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current calback function used by the converter when an illegal or invalid codepage sequence is found. 
<p>
Context pointers are always owned by the caller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>fillin: returns the callback function pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>fillin: returns the callback's private void* context </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#b1f96fe9de8e2ee39159f748a8d33a4b" title="Changes the callback function used by the converter when an illegal or invalid sequence...">ucnv_setToUCallBack</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000980">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="94a8af5dd3516cea50c2829e6c35b397"></a><!-- doxytag: member="ucnv.h::ucnv_getType" ref="94a8af5dd3516cea50c2829e6c35b397" args="(const UConverter *converter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucnv_8h.html#db0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a> ucnv_getType           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the type of the converter e.g. 
<p>
SBCS, MBCS, DBCS, UTF8, UTF16_BE, UTF16_LE, ISO_2022, EBCDIC_STATEFUL, LATIN_1 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>a valid, opened converter </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the type of the converter </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000976">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec7c273c8ce917ff75224e25914c53be"></a><!-- doxytag: member="ucnv.h::ucnv_getUnicodeSet" ref="ec7c273c8ce917ff75224e25914c53be" args="(const UConverter *cnv, USet *setFillIn, UConverterUnicodeSet whichSet, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_getUnicodeSet           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uset_8h.html#dce3fef7c15d7c78196bf977ac96ec9c">USet</a> *&nbsp;</td>
          <td class="paramname"> <em>setFillIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a>&nbsp;</td>
          <td class="paramname"> <em>whichSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the set of Unicode code points that can be converted by an ICU converter. 
<p>
The current implementation returns only one kind of set (UCNV_ROUNDTRIP_SET): The set of all Unicode code points that can be roundtrip-converted (converted without any data loss) with the converter. This set will not include code points that have fallback mappings or are only the result of reverse fallback mappings. See UTR #22 "Character Mapping Markup Language" at <a href="http://www.unicode.org/reports/tr22/">http://www.unicode.org/reports/tr22/</a><p>
This is useful for example for<ul>
<li>checking that a string or document can be roundtrip-converted with a converter, without/before actually performing the conversion</li><li>testing if a converter can be used for text for typical text for a certain locale, by comparing its roundtrip set with the set of ExemplarCharacters from ICU's locale data or other sources</li></ul>
<p>
In the future, there may be more UConverterUnicodeSet choices to select sets with different properties.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>The converter for which a set is requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>setFillIn</em>&nbsp;</td><td>A valid USet *. It will be cleared by this function before the converter's specific set is filled into the USet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>whichSet</em>&nbsp;</td><td>A UConverterUnicodeSet selector; currently UCNV_ROUNDTRIP_SET is the only supported value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#402221896b6d7153b14a5ff8dadde806" title="Selectors for Unicode sets that can be returned by ucnv_getUnicodeSet().">UConverterUnicodeSet</a> <p>
<a class="el" href="uset_8h.html#65a4e226273821916545e45dee27a144" title="Creates a USet object that contains the range of characters start.">uset_open</a> <p>
<a class="el" href="uset_8h.html#bb0d0fb8d660204fd7fef7fe920bb70c" title="Disposes of the storage used by a USet object.">uset_close</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000979">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="c38aa0a9daa58ca49dda17b2b7d40b8c"></a><!-- doxytag: member="ucnv.h::ucnv_isAmbiguous" ref="c38aa0a9daa58ca49dda17b2b7d40b8c" args="(const UConverter *cnv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> ucnv_isAmbiguous           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if the converter contains ambiguous mappings of the same character or not. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>the converter to be tested </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the converter contains ambiguous mapping of the same character, FALSE otherwise. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001008">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="485c78d4149165f504effa2287717e41"></a><!-- doxytag: member="ucnv.h::ucnv_open" ref="485c78d4149165f504effa2287717e41" args="(const char *converterName, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a>* ucnv_open           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>converterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a UConverter object with the name of a coded character set specified as a C string. 
<p>
The actual name will be resolved with the alias file using a case-insensitive string comparison that ignores leading zeroes and all non-alphanumeric characters. E.g., the names "UTF8", "utf-8", "u*T@f08" and "Utf 8" are all equivalent. (See also <a class="el" href="ucnv_8h.html#6f998746d8a8a8afd837f04dbb1ab64a" title="Do a fuzzy compare of two converter/alias names.">ucnv_compareNames()</a>.) If <code>NULL</code> is passed for the converter name, it will create one with the getDefaultName return value.<p>
A converter name for ICU 1.5 and above may contain options like a locale specification to control the specific behavior of the newly instantiated converter. The meaning of the options depends on the particular converter. If an option is not defined for or recognized by a given converter, then it is ignored.<p>
Options are appended to the converter name string, with a <code>UCNV_OPTION_SEP_CHAR</code> between the name and the first option and also between adjacent options.<p>
If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING.<p>
The conversion behavior and names can vary between platforms. ICU may convert some characters differently from other platforms. Details on this topic are in the <a href="http://icu-project.org/userguide/conversion.html">User's Guide</a>. Aliases starting with a "cp" prefix have no specific meaning other than its an alias starting with the letters "cp". Please do not associate any meaning to these aliases.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converterName</em>&nbsp;</td><td>Name of the coded character set table. This may have options appended to the string. IANA alias character set names, IBM CCSIDs starting with "ibm-", Windows codepage numbers starting with "windows-" are frequently used for this parameter. See ucnv_getAvailableName and ucnv_getAlias for a complete list that is available. If this parameter is NULL, the default converter will be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>outgoing error status <code>U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR</code> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created Unicode converter object, or <code>NULL</code> if an error occured </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#82e86d5341b39c543c269c70b8310f3e" title="Creates a Unicode converter with the names specified as unicode string.">ucnv_openU</a> <p>
<a class="el" href="ucnv_8h.html#9df0109e866c32078ab96fd2fe994b15" title="Creates a UConverter object from a CCSID number and platform pair.">ucnv_openCCSID</a> <p>
<a class="el" href="ucnv_8h.html#22feff7d04fe7a9dc62d1f7ecb4eb647" title="Gets the canonical converter name of the specified converter from a list of all available...">ucnv_getAvailableName</a> <p>
<a class="el" href="ucnv_8h.html#686d4e3d2905f3e2819577391fd08c2c" title="Gives the name of the alias at given index of alias list.">ucnv_getAlias</a> <p>
<a class="el" href="ucnv_8h.html#611d8da795489692511b07525a2f8b95" title="Returns the current default converter name.">ucnv_getDefaultName</a> <p>
<a class="el" href="ucnv_8h.html#1718689bf60724fdfa08c51aa0cc5ea0" title="Deletes the unicode converter and releases resources associated with just this instance...">ucnv_close</a>  <a class="el" href="ucnv_8h.html#6f998746d8a8a8afd837f04dbb1ab64a" title="Do a fuzzy compare of two converter/alias names.">ucnv_compareNames</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000954">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="23282ab66962108aa8eba7096e4499ed"></a><!-- doxytag: member="ucnv.h::ucnv_openAllNames" ref="23282ab66962108aa8eba7096e4499ed" args="(UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uenum_8h.html#32b7253b2148022535be36a9fcdb5a8d">UEnumeration</a>* ucnv_openAllNames           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a UEnumeration to enumerate all of the canonical converter names, as per the alias file, regardless of the ability to open each converter. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A UEnumeration object for getting all the recognized canonical converter names. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#22feff7d04fe7a9dc62d1f7ecb4eb647" title="Gets the canonical converter name of the specified converter from a list of all available...">ucnv_getAvailableName</a> <p>
<a class="el" href="uenum_8h.html#f8bf1abcf3a486f07ee3384c7fce89df" title="Disposes of resources in use by the iterator.">uenum_close</a> <p>
<a class="el" href="uenum_8h.html#99298eabaa3874cdfd9793b207848f68" title="Returns the next element in the iterator&#39;s list.">uenum_next</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000996">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div><p>
<a class="anchor" name="9df0109e866c32078ab96fd2fe994b15"></a><!-- doxytag: member="ucnv.h::ucnv_openCCSID" ref="9df0109e866c32078ab96fd2fe994b15" args="(int32_t codepage, UConverterPlatform platform, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a>* ucnv_openCCSID           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>codepage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#ba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a>&nbsp;</td>
          <td class="paramname"> <em>platform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a UConverter object from a CCSID number and platform pair. 
<p>
Note that the usefulness of this function is limited to platforms with numeric encoding IDs. Only IBM and Microsoft platforms use numeric (16-bit) identifiers for encodings.<p>
In addition, IBM CCSIDs and Unicode conversion tables are not 1:1 related. For many IBM CCSIDs there are multiple (up to six) Unicode conversion tables, and for some Unicode conversion tables there are multiple CCSIDs. Some "alternate" Unicode conversion tables are provided by the IBM CDRA conversion table registry. The most prominent example of a systematic modification of conversion tables that is not provided in the form of conversion table files in the repository is that S/390 Unix System Services swaps the codes for Line Feed and New Line in all EBCDIC codepages, which requires such a swap in the Unicode conversion tables as well.<p>
Only IBM default conversion tables are accessible with <a class="el" href="ucnv_8h.html#9df0109e866c32078ab96fd2fe994b15" title="Creates a UConverter object from a CCSID number and platform pair.">ucnv_openCCSID()</a>. <a class="el" href="ucnv_8h.html#0500738a0f4a552725725f9fe964e430" title="Gets a codepage number associated with the converter.">ucnv_getCCSID()</a> will return the same CCSID for all conversion tables that are associated with that CCSID.<p>
Currently, the only "platform" supported in the ICU converter API is UCNV_IBM.<p>
In summary, the use of CCSIDs and the associated API functions is not recommended.<p>
In order to open a converter with the default IBM CDRA Unicode conversion table, you can use this function or use the prefix "ibm-": <div class="fragment"><pre class="fragment">     <span class="keywordtype">char</span> name[20];
     sprintf(name, <span class="stringliteral">"ibm-%hu"</span>, ccsid);
     cnv=<a class="code" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a>(name, &amp;errorCode);
</pre></div><p>
In order to open a converter with the IBM S/390 Unix System Services variant of a Unicode/EBCDIC conversion table, you can use the prefix "ibm-" together with the option string UCNV_SWAP_LFNL_OPTION_STRING: <div class="fragment"><pre class="fragment">     <span class="keywordtype">char</span> name[20];
     sprintf(name, <span class="stringliteral">"ibm-%hu"</span> <a class="code" href="ucnv_8h.html#0588f7014923ad969821941f9dd51040" title="Converter option for EBCDIC SBCS or mixed-SBCS/DBCS (stateful) codepages.">UCNV_SWAP_LFNL_OPTION_STRING</a>, ccsid);
     cnv=<a class="code" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a>(name, &amp;errorCode);
</pre></div><p>
In order to open a converter from a Microsoft codepage number, use the prefix "cp": <div class="fragment"><pre class="fragment">     <span class="keywordtype">char</span> name[20];
     sprintf(name, <span class="stringliteral">"cp%hu"</span>, codepageID);
     cnv=<a class="code" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a>(name, &amp;errorCode);
</pre></div><p>
If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>codepage</em>&nbsp;</td><td>codepage number to create </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>platform</em>&nbsp;</td><td>the platform in which the codepage number exists </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>error status <code>U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR</code> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created Unicode converter object, or <code>NULL</code> if an error occured. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> <p>
<a class="el" href="ucnv_8h.html#82e86d5341b39c543c269c70b8310f3e" title="Creates a Unicode converter with the names specified as unicode string.">ucnv_openU</a> <p>
<a class="el" href="ucnv_8h.html#1718689bf60724fdfa08c51aa0cc5ea0" title="Deletes the unicode converter and releases resources associated with just this instance...">ucnv_close</a> <p>
<a class="el" href="ucnv_8h.html#0500738a0f4a552725725f9fe964e430" title="Gets a codepage number associated with the converter.">ucnv_getCCSID</a> <p>
<a class="el" href="ucnv_8h.html#a14f20f0ffa7f602690956cf3a5c87e2" title="Gets a codepage platform associated with the converter.">ucnv_getPlatform</a> <p>
<a class="el" href="ucnv_8h.html#ba5ba7fbc2f113618ba57f4d9825ff85" title="Enum for specifying which platform a converter ID refers to.">UConverterPlatform</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000956">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e3fc1e59ac1404120f242b8911cadbb"></a><!-- doxytag: member="ucnv.h::ucnv_openPackage" ref="7e3fc1e59ac1404120f242b8911cadbb" args="(const char *packageName, const char *converterName, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a>* ucnv_openPackage           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>packageName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>converterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a UConverter object specified from a packageName and a converterName.<p>
The packageName and converterName must point to an ICU udata object, as defined by <code> udata_open( packageName, "cnv", converterName, err) </code> or equivalent. Typically, packageName will refer to a (.dat) file, or to a package registered with <a class="el" href="udata_8h.html#406559067e309c05fb90b2d532f11835" title="This function bypasses the normal ICU data loading process for application-specific...">udata_setAppData()</a>. Using a full file or directory pathname for packageName is deprecated.<p>
The name will NOT be looked up in the alias mechanism, nor will the converter be stored in the converter cache or the alias table. The only way to open further converters is call this function multiple times, or use the <a class="el" href="ucnv_8h.html#11a66c267dce12a78dac2690d983d69e" title="Thread safe converter cloning operation.">ucnv_safeClone()</a> function to clone a 'master' converter.<p>
A future version of ICU may add alias table lookups and/or caching to this function.<p>
Example Use: <code>cnv = ucnv_openPackage("myapp", "myconverter", &amp;err);</code> <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packageName</em>&nbsp;</td><td>name of the package (equivalent to 'path' in <a class="el" href="udata_8h.html#3d908d77900b182403a375793ad35a86" title="Convenience function.">udata_open()</a> call) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>converterName</em>&nbsp;</td><td>name of the data item to be used, without suffix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>outgoing error status <code>U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR</code> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created Unicode converter object, or <code>NULL</code> if an error occured </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="udata_8h.html#3d908d77900b182403a375793ad35a86" title="Convenience function.">udata_open</a> <p>
<a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> <p>
<a class="el" href="ucnv_8h.html#11a66c267dce12a78dac2690d983d69e" title="Thread safe converter cloning operation.">ucnv_safeClone</a> <p>
<a class="el" href="ucnv_8h.html#1718689bf60724fdfa08c51aa0cc5ea0" title="Deletes the unicode converter and releases resources associated with just this instance...">ucnv_close</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000957">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6901c3ca8e871ef1efaa14d7f653d40"></a><!-- doxytag: member="ucnv.h::ucnv_openStandardNames" ref="b6901c3ca8e871ef1efaa14d7f653d40" args="(const char *convName, const char *standard, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uenum_8h.html#32b7253b2148022535be36a9fcdb5a8d">UEnumeration</a>* ucnv_openStandardNames           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>convName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>standard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a new UEnumeration object for enumerating all the alias names for a given converter that are recognized by a standard. 
<p>
This method only enumerates the listed entries in the alias file. The convrtrs.txt file can be modified to change the results of this function. The first result in this list is the same result given by <code>ucnv_getStandardName</code>, which is the default alias for the specified standard name. The returned object must be closed with <code>uenum_close</code> when you are done with the object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>convName</em>&nbsp;</td><td>original converter name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>standard</em>&nbsp;</td><td>name of the standard governing the names; MIME and IANA are such standards </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>The error code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A UEnumeration object for getting all aliases that are recognized by a standard. If any of the parameters are invalid, NULL is returned. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#2e1030c73ab423ec40b7b947320936c2" title="Returns a standard name for a given converter name.">ucnv_getStandardName</a> <p>
<a class="el" href="uenum_8h.html#f8bf1abcf3a486f07ee3384c7fce89df" title="Disposes of resources in use by the iterator.">uenum_close</a> <p>
<a class="el" href="uenum_8h.html#99298eabaa3874cdfd9793b207848f68" title="Returns the next element in the iterator&#39;s list.">uenum_next</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001000">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="82e86d5341b39c543c269c70b8310f3e"></a><!-- doxytag: member="ucnv.h::ucnv_openU" ref="82e86d5341b39c543c269c70b8310f3e" args="(const UChar *name, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a>* ucnv_openU           </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a Unicode converter with the names specified as unicode string. 
<p>
The name should be limited to the ASCII-7 alphanumerics range. The actual name will be resolved with the alias file using a case-insensitive string comparison that ignores leading zeroes and all non-alphanumeric characters. E.g., the names "UTF8", "utf-8", "u*T@f08" and "Utf 8" are all equivalent. (See also <a class="el" href="ucnv_8h.html#6f998746d8a8a8afd837f04dbb1ab64a" title="Do a fuzzy compare of two converter/alias names.">ucnv_compareNames()</a>.) If <code>NULL</code> is passed for the converter name, it will create one with the <a class="el" href="ucnv_8h.html#611d8da795489692511b07525a2f8b95" title="Returns the current default converter name.">ucnv_getDefaultName()</a> return value. If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING.<p>
See ucnv_open for the complete details <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the UConverter table in a zero terminated Unicode string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>outgoing error status <code>U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR</code> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created Unicode converter object, or <code>NULL</code> if an error occured </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open</a> <p>
<a class="el" href="ucnv_8h.html#9df0109e866c32078ab96fd2fe994b15" title="Creates a UConverter object from a CCSID number and platform pair.">ucnv_openCCSID</a> <p>
<a class="el" href="ucnv_8h.html#1718689bf60724fdfa08c51aa0cc5ea0" title="Deletes the unicode converter and releases resources associated with just this instance...">ucnv_close</a>  <a class="el" href="ucnv_8h.html#6f998746d8a8a8afd837f04dbb1ab64a" title="Do a fuzzy compare of two converter/alias names.">ucnv_compareNames</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000955">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ce43ec88f1615422f3c5c972ae79deba"></a><!-- doxytag: member="ucnv.h::ucnv_reset" ref="ce43ec88f1615422f3c5c972ae79deba" args="(UConverter *converter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_reset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the state of a converter to the default state. 
<p>
This is used in the case of an error, to restart a conversion from a known default state. It will also empty the internal output buffers. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000966">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba8147239dca1fe5773de4905f2f74c2"></a><!-- doxytag: member="ucnv.h::ucnv_resetFromUnicode" ref="ba8147239dca1fe5773de4905f2f74c2" args="(UConverter *converter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_resetFromUnicode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the from-Unicode part of a converter state to the default state. 
<p>
This is used in the case of an error to restart a conversion from Unicode to a known default state. It will also empty the internal output buffers used for the conversion from Unicode codepoints. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000968">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="8711b61a6cd41d84cf522042b3aebaed"></a><!-- doxytag: member="ucnv.h::ucnv_resetToUnicode" ref="8711b61a6cd41d84cf522042b3aebaed" args="(UConverter *converter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_resetToUnicode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the to-Unicode part of a converter state to the default state. 
<p>
This is used in the case of an error to restart a conversion to Unicode to a known default state. It will also empty the internal output buffers used for the conversion to Unicode codepoints. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000967">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="11a66c267dce12a78dac2690d983d69e"></a><!-- doxytag: member="ucnv.h::ucnv_safeClone" ref="11a66c267dce12a78dac2690d983d69e" args="(const UConverter *cnv, void *stackBuffer, int32_t *pBufferSize, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a>* ucnv_safeClone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Thread safe converter cloning operation. 
<p>
For most efficient operation, pass in a stackBuffer (and a *pBufferSize) with at least U_CNV_SAFECLONE_BUFFERSIZE bytes of space. If the buffer size is sufficient, then the clone will use the stack buffer; otherwise, it will be allocated, and *pBufferSize will indicate the actual size. (This should not occur with U_CNV_SAFECLONE_BUFFERSIZE.)<p>
You must <a class="el" href="ucnv_8h.html#1718689bf60724fdfa08c51aa0cc5ea0" title="Deletes the unicode converter and releases resources associated with just this instance...">ucnv_close()</a> the clone in any case.<p>
If *pBufferSize==0, (regardless of whether stackBuffer==NULL or not) then *pBufferSize will be changed to a sufficient size for cloning this converter, without actually cloning the converter ("pure pre-flighting").<p>
If *pBufferSize is greater than zero but not large enough for a stack-based clone, then the converter is cloned using newly allocated memory and *pBufferSize is changed to the necessary size.<p>
If the converter clone fits into the stack buffer but the stack buffer is not sufficiently aligned for the clone, then the clone will use an adjusted pointer and use an accordingly smaller buffer size.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>converter to be cloned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stackBuffer</em>&nbsp;</td><td>user allocated space for the new clone. If NULL new memory will be allocated. If buffer is not large enough, new memory will be allocated. Clients can use the U_CNV_SAFECLONE_BUFFERSIZE. This will probably be enough to avoid memory allocations. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBufferSize</em>&nbsp;</td><td>pointer to size of allocated space. pBufferSize must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>to indicate whether the operation went on smoothly or there were errors An informational status value, U_SAFECLONE_ALLOCATED_WARNING, is used if any allocations were necessary. However, it is better to check if *pBufferSize grew for checking for allocations because warning codes can be overridden by subsequent function calls. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the new clone </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000958">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a2aaa1bd664b8b53da8cb50f1025bf9"></a><!-- doxytag: member="ucnv.h::ucnv_setDefaultName" ref="1a2aaa1bd664b8b53da8cb50f1025bf9" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_setDefaultName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is not thread safe. 
<p>
DO NOT call this function when ANY ICU function is being used from more than one thread! This function sets the current default converter name. If this function needs to be called, it should be called during application initialization. Most of the time, the results from <a class="el" href="ucnv_8h.html#611d8da795489692511b07525a2f8b95" title="Returns the current default converter name.">ucnv_getDefaultName()</a> or ucnv_open with a NULL string argument is sufficient for your application. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the converter name to be the default (must be known by ICU). </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#611d8da795489692511b07525a2f8b95" title="Returns the current default converter name.">ucnv_getDefaultName</a> </dd></dl>
<dl compact><dt><b><a class="el" href="system.html#_system000014">System:</a></b></dt><dd>Do not use unless you know what you are doing. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001006">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="117c45b5c1d746c6f532f44985b686e4"></a><!-- doxytag: member="ucnv.h::ucnv_setFallback" ref="117c45b5c1d746c6f532f44985b686e4" args="(UConverter *cnv, UBool usesFallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_setFallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>usesFallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the converter to use fallback mappings or not. 
<p>
Regardless of this flag, the converter will always use fallbacks from Unicode Private Use code points, as well as reverse fallbacks (to Unicode). For details see ".ucm File Format" in the Conversion Data chapter of the ICU User Guide: <a href="http://www.icu-project.org/userguide/conversion-data.html#ucmformat">http://www.icu-project.org/userguide/conversion-data.html#ucmformat</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>The converter to set the fallback mapping usage on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usesFallback</em>&nbsp;</td><td>TRUE if the user wants the converter to take advantage of the fallback mapping, FALSE otherwise. </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001009">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#036433918c08965c4c687892036db3eb" title="Determines if the converter uses fallback mappings or not.">ucnv_usesFallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="59fdaf2cf5dc57d738ed7a7657f6b03a"></a><!-- doxytag: member="ucnv.h::ucnv_setFromUCallBack" ref="59fdaf2cf5dc57d738ed7a7657f6b03a" args="(UConverter *converter, UConverterFromUCallback newAction, const void *newContext, UConverterFromUCallback *oldAction, const void **oldContext, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_setFromUCallBack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UConverterFromUCallback&nbsp;</td>
          <td class="paramname"> <em>newAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>newContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UConverterFromUCallback *&nbsp;</td>
          <td class="paramname"> <em>oldAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&nbsp;</td>
          <td class="paramname"> <em>oldContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes the current callback function used by the converter when an illegal or invalid sequence is found. 
<p>
Context pointers are always owned by the caller. Predefined actions and contexts can be found in the <a class="el" href="ucnv__err_8h.html" title="C UConverter predefined error callbacks.">ucnv_err.h</a> header.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newAction</em>&nbsp;</td><td>the new callback function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newContext</em>&nbsp;</td><td>the new fromUnicode callback context pointer. This can be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldAction</em>&nbsp;</td><td>fillin: returns the old callback function pointer. This can be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldContext</em>&nbsp;</td><td>fillin: returns the old callback's private void* context. This can be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>The error code status </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#2a2dcbf10e3b08a97ed0b06466d9e8a5" title="Gets the current callback function used by the converter when illegal or invalid...">ucnv_getFromUCallBack</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000983">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="c160b1b44ac9b5124ec083810709603a"></a><!-- doxytag: member="ucnv.h::ucnv_setSubstChars" ref="c160b1b44ac9b5124ec083810709603a" args="(UConverter *converter, const char *subChars, int8_t len, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_setSubstChars           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>subChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the substitution chars when converting from unicode to a codepage. 
<p>
The substitution is specified as a string of 1-4 bytes, and may contain <code>NULL</code> bytes. The subChars must represent a single character. The caller needs to know the byte sequence of a valid character in the converter's charset. For some converters, for example some ISO 2022 variants, only single-byte substitution characters may be supported. The newer <a class="el" href="ucnv_8h.html#f87333c550d699794ab84151ed9007c6" title="Set a substitution string for converting from Unicode to a charset.">ucnv_setSubstString()</a> function relaxes these limitations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subChars</em>&nbsp;</td><td>the substitution character byte sequence we want set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the number of bytes in subChars </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>the error status code. <code>U_INDEX_OUTOFBOUNDS_ERROR </code> if len is bigger than the maximum number of bytes allowed in subchars </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#f87333c550d699794ab84151ed9007c6" title="Set a substitution string for converting from Unicode to a charset.">ucnv_setSubstString</a> <p>
<a class="el" href="ucnv_8h.html#118a87477ffa827d00dd50727da02e31" title="Fills in the output parameter, subChars, with the substitution characters as multiple...">ucnv_getSubstChars</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000962">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="f87333c550d699794ab84151ed9007c6"></a><!-- doxytag: member="ucnv.h::ucnv_setSubstString" ref="f87333c550d699794ab84151ed9007c6" args="(UConverter *cnv, const UChar *s, int32_t length, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_setSubstString           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a substitution string for converting from Unicode to a charset. 
<p>
The caller need not know the charset byte sequence for each charset.<p>
Unlike <a class="el" href="ucnv_8h.html#c160b1b44ac9b5124ec083810709603a" title="Sets the substitution chars when converting from unicode to a codepage.">ucnv_setSubstChars()</a> which is designed to set a charset byte sequence for a single character, this function takes a Unicode string with zero, one or more characters, and immediately verifies that the string can be converted to the charset. If not, or if the result is too long (more than 32 bytes as of ICU 3.6), then the function returns with an error accordingly.<p>
Also unlike <a class="el" href="ucnv_8h.html#c160b1b44ac9b5124ec083810709603a" title="Sets the substitution chars when converting from unicode to a codepage.">ucnv_setSubstChars()</a>, this function works for stateful charsets by converting on the fly at the point of substitution rather than setting a fixed byte sequence.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>The UConverter object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The Unicode string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of UChars in s, or -1 for a NUL-terminated string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to a standard ICU error code. Its input value must pass the <a class="el" href="utypes_8h.html#527f2c69e6b2e3b2c53ad8a99fb36711" title="Does the error code indicate success?">U_SUCCESS()</a> test, or else the function returns immediately. Check for <a class="el" href="utypes_8h.html#4d202200b6aa6f3c965ea370e0c8155f" title="Does the error code indicate a failure?">U_FAILURE()</a> on output or use with function chaining. (See User Guide for details.)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#c160b1b44ac9b5124ec083810709603a" title="Sets the substitution chars when converting from unicode to a codepage.">ucnv_setSubstChars</a> <p>
<a class="el" href="ucnv_8h.html#118a87477ffa827d00dd50727da02e31" title="Fills in the output parameter, subChars, with the substitution characters as multiple...">ucnv_getSubstChars</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000963">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b1f96fe9de8e2ee39159f748a8d33a4b"></a><!-- doxytag: member="ucnv.h::ucnv_setToUCallBack" ref="b1f96fe9de8e2ee39159f748a8d33a4b" args="(UConverter *converter, UConverterToUCallback newAction, const void *newContext, UConverterToUCallback *oldAction, const void **oldContext, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_setToUCallBack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UConverterToUCallback&nbsp;</td>
          <td class="paramname"> <em>newAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>newContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UConverterToUCallback *&nbsp;</td>
          <td class="paramname"> <em>oldAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&nbsp;</td>
          <td class="paramname"> <em>oldContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes the callback function used by the converter when an illegal or invalid sequence is found. 
<p>
Context pointers are always owned by the caller. Predefined actions and contexts can be found in the <a class="el" href="ucnv__err_8h.html" title="C UConverter predefined error callbacks.">ucnv_err.h</a> header.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newAction</em>&nbsp;</td><td>the new callback function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newContext</em>&nbsp;</td><td>the new toUnicode callback context pointer. This can be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldAction</em>&nbsp;</td><td>fillin: returns the old callback function pointer. This can be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldContext</em>&nbsp;</td><td>fillin: returns the old callback's private void* context. This can be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>The error code status </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#f45faec39053767f4a7a779586c24223" title="Gets the current calback function used by the converter when an illegal or invalid...">ucnv_getToUCallBack</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000982">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b619c24f88f8b10f97b64ab1dc4fc86"></a><!-- doxytag: member="ucnv.h::ucnv_toAlgorithmic" ref="1b619c24f88f8b10f97b64ab1dc4fc86" args="(UConverterType algorithmicType, UConverter *cnv, char *target, int32_t targetCapacity, const char *source, int32_t sourceLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_toAlgorithmic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#db0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a>&nbsp;</td>
          <td class="paramname"> <em>algorithmicType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>targetCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sourceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert from one external charset to another. 
<p>
Internally, the text is converted to and from the 16-bit Unicode "pivot" using <a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a>. <a class="el" href="ucnv_8h.html#1b619c24f88f8b10f97b64ab1dc4fc86" title="Convert from one external charset to another.">ucnv_toAlgorithmic()</a> works exactly like <a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert()</a> except that the two converters need not be looked up and opened completely.<p>
The source-to-pivot conversion uses the cnv converter parameter. The pivot-to-target conversion uses a purely algorithmic converter according to the specified type, e.g., UCNV_UTF8 for a UTF-8 converter.<p>
Internally, the algorithmic converter is opened and closed for each function call, which is more efficient than using the public <a class="el" href="ucnv_8h.html#485c78d4149165f504effa2287717e41" title="Creates a UConverter object with the name of a coded character set specified as a...">ucnv_open()</a> but somewhat less efficient than only resetting an existing converter and using <a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a>.<p>
This function is more convenient than <a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx()</a> for single-string conversions, especially when "preflighting" is desired (returning the length of the complete output even if it does not fit into the target buffer; see the User Guide Strings chapter). See <a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert()</a> for details.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>algorithmicType</em>&nbsp;</td><td>UConverterType constant identifying the desired target charset as a purely algorithmic converter. Those are converters for Unicode charsets like UTF-8, BOCU-1, SCSU, UTF-7, IMAP-mailbox-name, etc., as well as US-ASCII and ISO-8859-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>The converter that is used to convert from the source to the UTF-16 pivot buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Pointer to the output buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targetCapacity</em>&nbsp;</td><td>Capacity of the target, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Pointer to the input buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLength</em>&nbsp;</td><td>Length of the input text, in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Length of the complete output text in bytes, even if it exceeds the targetCapacity and a U_BUFFER_OVERFLOW_ERROR is set.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#5cd24dc4d6c2fbec8c6481309459b7d5" title="Convert from one external charset to another.">ucnv_fromAlgorithmic</a> <p>
<a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert</a> <p>
<a class="el" href="ucnv_8h.html#f4c967c5afa207d064c24e19256586b6" title="Convert from one external charset to another using two existing UConverters.">ucnv_convertEx</a> <p>
<a class="el" href="ucnv_8h.html#4a1f09772549fbcd7dd782297212c19f" title="Converts an array of unicode characters to an array of codepage characters.">ucnv_fromUnicode</a> <p>
<a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode</a> <p>
<a class="el" href="ucnv_8h.html#31bd5a5af440108a1a51bb0234ad32ac" title="Convert the Unicode string into a codepage string using an existing UConverter.">ucnv_fromUChars</a> <p>
<a class="el" href="ucnv_8h.html#1493c21231f237e6197c027229389ff8" title="Convert the codepage string into a Unicode string using an existing UConverter.">ucnv_toUChars</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000991">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1493c21231f237e6197c027229389ff8"></a><!-- doxytag: member="ucnv.h::ucnv_toUChars" ref="1493c21231f237e6197c027229389ff8" args="(UConverter *cnv, UChar *dest, int32_t destCapacity, const char *src, int32_t srcLength, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_toUChars           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the codepage string into a Unicode string using an existing UConverter. 
<p>
The output string is NUL-terminated if possible.<p>
This function is a more convenient but less powerful version of <a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode()</a>. It is only useful for whole strings, not for streaming conversion.<p>
The maximum output buffer capacity required (barring output from callbacks) will be 2*srcLength (each char may be converted into a surrogate pair).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>the converter object to be used (<a class="el" href="ucnv_8h.html#8711b61a6cd41d84cf522042b3aebaed" title="Resets the to-Unicode part of a converter state to the default state.">ucnv_resetToUnicode()</a> will be called) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the input codepage string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>the input string length, or -1 if NUL-terminated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination string buffer, can be NULL if destCapacity==0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>the number of UChars available at dest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>normal ICU error code; common error codes that may be set by this function include U_BUFFER_OVERFLOW_ERROR, U_STRING_NOT_TERMINATED_WARNING, U_ILLEGAL_ARGUMENT_ERROR, and conversion errors </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the length of the output string, not counting the terminating NUL; if the length is greater than destCapacity, then the string will not fit and a buffer of the indicated length would need to be passed in </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#fbea5eb35a5ec1517a548ffc868a5599" title="Converts a buffer of codepage bytes into an array of unicode UChars characters.">ucnv_toUnicode</a> <p>
<a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000987">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="607e2305f45490a01fd8a32261e32e0c"></a><!-- doxytag: member="ucnv.h::ucnv_toUCountPending" ref="607e2305f45490a01fd8a32261e32e0c" args="(const UConverter *cnv, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ucnv_toUCountPending           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of chars held in the converter's internal state because more input is needed for completing the conversion. 
<p>
This function is useful for mapping semantics of ICU's converter interface to those of iconv, and this information is not needed for normal conversion. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>The converter in which the input is held as internal state </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of chars in the state. -1 if an error is encountered. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001013">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div><p>
<a class="anchor" name="fbea5eb35a5ec1517a548ffc868a5599"></a><!-- doxytag: member="ucnv.h::ucnv_toUnicode" ref="fbea5eb35a5ec1517a548ffc868a5599" args="(UConverter *converter, UChar **target, const UChar *targetLimit, const char **source, const char *sourceLimit, int32_t *offsets, UBool flush, UErrorCode *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucnv_toUnicode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar **&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>targetLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>sourceLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a buffer of codepage bytes into an array of unicode UChars characters. 
<p>
This function is optimized for converting a continuous stream of data in buffer-sized chunks, where the entire source and target does not fit in available buffers.<p>
The source pointer is an in/out parameter. It starts out pointing where the conversion is to begin, and ends up pointing after the last byte of source consumed.<p>
Target similarly starts out pointer at the first available UChar in the output buffer, and ends up pointing after the last UChar written to the output. It does NOT necessarily keep UChar sequences together.<p>
The converter always attempts to consume the entire source buffer, unless (1.) the target buffer is full, or (2.) a failing error is returned from the current callback function. When a successful error status has been returned, it means that all of the source buffer has been consumed. At that point, the caller should reset the source and sourceLimit pointers to point to the next chunk.<p>
At the end of the stream (flush==TRUE), the input is completely consumed when *source==sourceLimit and no error code is set The converter object is then automatically reset by this function. (This means that a converter need not be reset explicitly between data streams if it finishes the previous stream without errors.)<p>
This is a <em>stateful</em> conversion. Additionally, even when all source data has been consumed, some data may be in the converters' internal state. Call this function repeatedly, updating the target pointers with the next empty chunk of target in case of a <code>U_BUFFER_OVERFLOW_ERROR</code>, and updating the source pointers with the next chunk of source when a successful error status is returned, until there are no more chunks of source data. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>converter</em>&nbsp;</td><td>the Unicode converter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>I/O parameter. Input : Points to the beginning of the buffer to copy UChars into. Output : points to after the last UChar copied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targetLimit</em>&nbsp;</td><td>the pointer just after the end of the <code>target</code> buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>I/O parameter, pointer to pointer to the source codepage buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLimit</em>&nbsp;</td><td>the pointer to the byte after the end of the source buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offsets</em>&nbsp;</td><td>if NULL is passed, nothing will happen to it, otherwise it needs to have the same number of allocated cells as <code>target</code>. Will fill in offsets from target to source pointer e.g: <code>offsets[3]</code> is equal to 6, it means that the <code>target[3]</code> was a result of transcoding <code>source[6]</code> For output data carried across calls, and other data without a specific source character (such as from escape sequences or callbacks) -1 will be placed for offsets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flush</em>&nbsp;</td><td>set to <code>TRUE</code> if the current source buffer is the last available chunk of the source, <code>FALSE</code> otherwise. Note that if a failing status is returned, this function may have to be called multiple times with flush set to <code>TRUE</code> until the source buffer is consumed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>the error status. <code>U_ILLEGAL_ARGUMENT_ERROR</code> will be set if the converter is <code>NULL</code>. <code>U_BUFFER_OVERFLOW_ERROR</code> will be set if the target is full and there is still data to be written to the target. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#31bd5a5af440108a1a51bb0234ad32ac" title="Convert the Unicode string into a codepage string using an existing UConverter.">ucnv_fromUChars</a> <p>
<a class="el" href="ucnv_8h.html#2bdb6b1d3ac4069808348eb6961ce63d" title="Convert from one external charset to another.">ucnv_convert</a> <p>
<a class="el" href="ucnv_8h.html#12edd465a611c41e418632f5d5f2dbe4" title="Returns the minimum byte length for characters in this codepage.">ucnv_getMinCharSize</a> <p>
<a class="el" href="ucnv_8h.html#59fdaf2cf5dc57d738ed7a7657f6b03a" title="Changes the current callback function used by the converter when an illegal or invalid...">ucnv_setFromUCallBack</a> <p>
<a class="el" href="ucnv_8h.html#af391b89870fd88b3da838eff1bd6ba6" title="Convert a codepage buffer into Unicode one character at a time.">ucnv_getNextUChar</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000985">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="036433918c08965c4c687892036db3eb"></a><!-- doxytag: member="ucnv.h::ucnv_usesFallback" ref="036433918c08965c4c687892036db3eb" args="(const UConverter *cnv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#349ef00011f20ccd1d3b424445681aa5">UBool</a> ucnv_usesFallback           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>cnv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if the converter uses fallback mappings or not. 
<p>
This flag has restrictions, see <a class="el" href="ucnv_8h.html#117c45b5c1d746c6f532f44985b686e4" title="Sets the converter to use fallback mappings or not.">ucnv_setFallback()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnv</em>&nbsp;</td><td>The converter to be tested </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the converter uses fallback, FALSE otherwise. </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable001010">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#117c45b5c1d746c6f532f44985b686e4" title="Sets the converter to use fallback mappings or not.">ucnv_setFallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a953bd3cedaedf78b700c837361fe00b"></a><!-- doxytag: member="ucnv.h::void" ref="a953bd3cedaedf78b700c837361fe00b" args="(1 *UConverterToUCallback)(const void *context" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void           </td>
          <td>(</td>
          <td class="paramtype">1 *&nbsp;</td>
          <td class="paramname"> <em>UConverterFromUCallback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function pointer for error callback in the codepage to unicode direction. 
<p>
Function pointer for error callback in the unicode to codepage direction.<p>
Called when an error has occured in conversion to unicode, or on open/close of the callback (see reason). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>Pointer to the callback's private data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>Information about the conversion in progress </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>codeUnits</em>&nbsp;</td><td>Points to 'length' bytes of the concerned codepage sequence </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Size (in bytes) of the concerned codepage sequence </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>Defines the reason the callback was invoked </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. For converter callback functions, set to a conversion error before the call, and the callback may reset it to U_ZERO_ERROR. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#b1f96fe9de8e2ee39159f748a8d33a4b" title="Changes the callback function used by the converter when an illegal or invalid sequence...">ucnv_setToUCallBack</a> <p>
<a class="el" href="structUConverterToUnicodeArgs.html" title="The structure for the toUnicode callback function parameter.">UConverterToUnicodeArgs</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000944">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
Called when an error has occured in conversion from unicode, or on open/close of the callback (see reason). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>Pointer to the callback's private data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>Information about the conversion in progress </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>codeUnits</em>&nbsp;</td><td>Points to 'length' UChars of the concerned Unicode sequence </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Size (in bytes) of the concerned codepage sequence </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>codePoint</em>&nbsp;</td><td>Single UChar32 (UTF-32) containing the concerend Unicode codepoint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>Defines the reason the callback was invoked </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. For converter callback functions, set to a conversion error before the call, and the callback may reset it to U_ZERO_ERROR. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="ucnv_8h.html#59fdaf2cf5dc57d738ed7a7657f6b03a" title="Changes the current callback function used by the converter when an illegal or invalid...">ucnv_setFromUCallBack</a> </dd></dl>
<dl compact><dt><b><a class="el" href="stable.html#_stable000945">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 28 17:50:02 2008 for ICU 3.8 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
