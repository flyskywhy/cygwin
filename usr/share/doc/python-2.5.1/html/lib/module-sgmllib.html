<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<link rel="STYLESHEET" href="lib.css" type='text/css' />
<link rel="SHORTCUT ICON" href="../icons/pyfav.png" type="image/png" />
<link rel='start' href='../index.html' title='Python documentation Index' />
<link rel="first" href="lib.html" title='Python library Reference' />
<link rel='contents' href='contents.html' title="Contents" />
<link rel='index' href='genindex.html' title='Index' />
<link rel='last' href='about.html' title='About this document...' />
<link rel='help' href='about.html' title='About this document...' />
<link rel="next" href="module-htmllib.html" />
<link rel="prev" href="module-HTMLParser.html" />
<link rel="parent" href="markup.html" />
<link rel="next" href="module-htmllib.html" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name='aesop' content='information' />
<title>8.2 sgmllib -- Simple SGML parser</title>
</head>
<body>
<div class="navigation">
<div id='top-navigation-panel' xml:id='top-navigation-panel'>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="8.1.1 example HTML Parser"
  href="htmlparser-example.html"><img src='../icons/previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></a></td>
<td class='online-navigation'><a rel="parent" title="8. structured Markup Processing"
  href="markup.html"><img src='../icons/up.png'
  border='0' height='32'  alt='Up one Level' width='32' /></a></td>
<td class='online-navigation'><a rel="next" title="8.3 htmllib  "
  href="module-htmllib.html"><img src='../icons/next.png'
  border='0' height='32'  alt='Next Page' width='32' /></a></td>
<td align="center" width="100%">Python Library Reference</td>
<td class='online-navigation'><a rel="contents" title="Table of Contents"
  href="contents.html"><img src='../icons/contents.png'
  border='0' height='32'  alt='Contents' width='32' /></a></td>
<td class='online-navigation'><a href="modindex.html" title="Module Index"><img src='../icons/modules.png'
  border='0' height='32'  alt='Module Index' width='32' /></a></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='../icons/index.png'
  border='0' height='32'  alt='Index' width='32' /></a></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="htmlparser-example.html">8.1.1 Example HTML Parser</a>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="markup.html">8. Structured Markup Processing</a>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="module-htmllib.html">8.3 htmllib  </a>
</div>
<hr /></div>
</div>
<!--End of Navigation Panel-->

<h1><a name="SECTION0010200000000000000000">
8.2 <tt class="module">sgmllib</tt> --
         Simple SGML parser</a>
</h1>

<p>
<a name="module-sgmllib"></a>

<p>
<a id='l2h-1692' xml:id='l2h-1692'></a>

<p>
This module defines a class <tt class="class">SGMLParser</tt> which serves as the
basis for parsing text files formatted in SGML (Standard Generalized
Mark-up Language).  In fact, it does not provide a full SGML parser
-- it only parses SGML insofar as it is used by HTML, and the module
only exists as a base for the <tt class="module"><a href="module-htmllib.html">htmllib</a></tt> module.  Another
HTML parser which supports XHTML and offers a somewhat different
interface is available in the <tt class="module"><a href="module-HTMLParser.html">HTMLParser</a></tt> module.

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<tt id='l2h-1669' xml:id='l2h-1669' class="class">SGMLParser</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
The <tt class="class">SGMLParser</tt> class is instantiated without arguments.
The parser is hardcoded to recognize the following
constructs:

<p>

<ul>
<li>Opening and closing tags of the form
"<tt class="samp">&lt;<var>tag</var> <var>attr</var>="<var>value</var>" ...&gt;</tt>" and
"<tt class="samp">&lt;/<var>tag</var>&gt;</tt>", respectively.

<p>
</li>
<li>Numeric character references of the form "<tt class="samp">&amp;#<var>name</var>;</tt>".

<p>
</li>
<li>Entity references of the form "<tt class="samp">&amp;<var>name</var>;</tt>".

<p>
</li>
<li>SGML comments of the form "<tt class="samp">&lt;!--<var>text</var>--&gt;</tt>".  Note that
spaces, tabs, and newlines are allowed between the trailing
"<tt class="samp">&gt;</tt>" and the immediately preceding "<tt class="samp">--</tt>".

<p>
</li>
</ul>
</dl>

<p>
A single exception is defined as well:

<p>
<dl><dt><b><span class="typelabel">exception</span>&nbsp;<tt id='l2h-1670' xml:id='l2h-1670' class="exception">SGMLParseError</tt></b></dt>
<dd>
Exception raised by the <tt class="class">SGMLParser</tt> class when it encounters an
error while parsing.

<span class="versionnote">New in version 2.1.</span>

</dd></dl>

<p>
<tt class="class">SGMLParser</tt> instances have the following methods:

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1671' xml:id='l2h-1671' class="method">reset</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Reset the instance.  Loses all unprocessed data.  This is called
implicitly at instantiation time.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1672' xml:id='l2h-1672' class="method">setnomoretags</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Stop processing tags.  Treat all following input as literal input
(CDATA).  (This is only provided so the HTML tag
<code>&lt;PLAINTEXT&gt;</code> can be implemented.)
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1673' xml:id='l2h-1673' class="method">setliteral</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Enter literal mode (CDATA mode).
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1674' xml:id='l2h-1674' class="method">feed</tt></b>(</nobr></td>
  <td><var>data</var>)</td></tr></table></dt>
<dd>
Feed some text to the parser.  It is processed insofar as it consists
of complete elements; incomplete data is buffered until more data is
fed or <tt class="method">close()</tt> is called.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1675' xml:id='l2h-1675' class="method">close</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Force processing of all buffered data as if it were followed by an
end-of-file mark.  This method may be redefined by a derived class to
define additional processing at the end of the input, but the
redefined version should always call <tt class="method">close()</tt>.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1676' xml:id='l2h-1676' class="method">get_starttag_text</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the text of the most recently opened start tag.  This should
not normally be needed for structured processing, but may be useful in
dealing with HTML ``as deployed'' or for re-generating input with
minimal changes (whitespace between attributes can be preserved,
etc.).
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1677' xml:id='l2h-1677' class="method">handle_starttag</tt></b>(</nobr></td>
  <td><var>tag, method, attributes</var>)</td></tr></table></dt>
<dd>
This method is called to handle start tags for which either a
<tt class="method">start_<var>tag</var>()</tt> or <tt class="method">do_<var>tag</var>()</tt> method has been
defined.  The <var>tag</var> argument is the name of the tag converted to
lower case, and the <var>method</var> argument is the bound method which
should be used to support semantic interpretation of the start tag.
The <var>attributes</var> argument is a list of <code>(<var>name</var>,
<var>value</var>)</code> pairs containing the attributes found inside the tag's
<code>&lt;&gt;</code> brackets.

<p>
The <var>name</var> has been translated to lower case.
Double quotes and backslashes in the <var>value</var> have been interpreted,
as well as known character references and known entity references
terminated by a semicolon (normally, entity references can be terminated
by any non-alphanumerical character, but this would break the very
common case of <code>&lt;A HREF="url?spam=1&amp;eggs=2"&gt;</code> when <code>eggs</code>
is a valid entity name).

<p>
For instance, for the tag <code>&lt;A HREF="http://www.cwi.nl/"&gt;</code>, this
method would be called as "<tt class="samp">unknown_starttag('a', [('href',
'http://www.cwi.nl/')])</tt>".  The base implementation simply calls
<var>method</var> with <var>attributes</var> as the only argument.

<span class="versionnote">New in version 2.5:
Handling of entity and character references within
              attribute values.</span>

</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1678' xml:id='l2h-1678' class="method">handle_endtag</tt></b>(</nobr></td>
  <td><var>tag, method</var>)</td></tr></table></dt>
<dd>
This method is called to handle endtags for which an
<tt class="method">end_<var>tag</var>()</tt> method has been defined.  The
<var>tag</var> argument is the name of the tag converted to lower case, and
the <var>method</var> argument is the bound method which should be used to
support semantic interpretation of the end tag.  If no
<tt class="method">end_<var>tag</var>()</tt> method is defined for the closing element,
this handler is not called.  The base implementation simply calls
<var>method</var>.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1679' xml:id='l2h-1679' class="method">handle_data</tt></b>(</nobr></td>
  <td><var>data</var>)</td></tr></table></dt>
<dd>
This method is called to process arbitrary data.  It is intended to be
overridden by a derived class; the base class implementation does
nothing.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1680' xml:id='l2h-1680' class="method">handle_charref</tt></b>(</nobr></td>
  <td><var>ref</var>)</td></tr></table></dt>
<dd>
This method is called to process a character reference of the form
"<tt class="samp">&amp;#<var>ref</var>;</tt>".  The base implementation uses
<tt class="method">convert_charref()</tt> to convert the reference to a string.  If
that method returns a string, it is passed to <tt class="method">handle_data()</tt>,
otherwise <tt class="method">unknown_charref(<var>ref</var>)</tt> is called to handle the
error.

<span class="versionnote">Changed in version 2.5:
Use <tt class="method">convert_charref()</tt> instead of hard-coding
the conversion.</span>

</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1681' xml:id='l2h-1681' class="method">convert_charref</tt></b>(</nobr></td>
  <td><var>ref</var>)</td></tr></table></dt>
<dd>
Convert a character reference to a string, or <code>None</code>.  <var>ref</var>
is the reference passed in as a string.  In the base implementation,
<var>ref</var> must be a decimal number in the range 0-255.  It converts
the code point found using the <tt class="method">convert_codepoint()</tt> method.
If <var>ref</var> is invalid or out of range, this method returns
<code>None</code>.  This method is called by the default
<tt class="method">handle_charref()</tt> implementation and by the attribute value
parser.

<span class="versionnote">New in version 2.5.</span>

</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1682' xml:id='l2h-1682' class="method">convert_codepoint</tt></b>(</nobr></td>
  <td><var>codepoint</var>)</td></tr></table></dt>
<dd>
Convert a codepoint to a <tt class="class">str</tt> value.  Encodings can be handled
here if appropriate, though the rest of <tt class="module">sgmllib</tt> is oblivious
on this matter.

<span class="versionnote">New in version 2.5.</span>

</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1683' xml:id='l2h-1683' class="method">handle_entityref</tt></b>(</nobr></td>
  <td><var>ref</var>)</td></tr></table></dt>
<dd>
This method is called to process a general entity reference of the
form "<tt class="samp">&amp;<var>ref</var>;</tt>" where <var>ref</var> is an general entity
reference.  It converts <var>ref</var> by passing it to
<tt class="method">convert_entityref()</tt>.  If a translation is returned, it
calls the method <tt class="method">handle_data()</tt> with the translation;
otherwise, it calls the method <code>unknown_entityref(<var>ref</var>)</code>.
The default <tt class="member">entitydefs</tt> defines translations for
<code>&amp;amp;</code>, <code>&amp;apos</code>, <code>&amp;gt;</code>, <code>&amp;lt;</code>, and
<code>&amp;quot;</code>.

<span class="versionnote">Changed in version 2.5:
Use <tt class="method">convert_entityref()</tt> instead of hard-coding
the conversion.</span>

</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1684' xml:id='l2h-1684' class="method">convert_entityref</tt></b>(</nobr></td>
  <td><var>ref</var>)</td></tr></table></dt>
<dd>
Convert a named entity reference to a <tt class="class">str</tt> value, or
<code>None</code>.  The resulting value will not be parsed.  <var>ref</var> will
be only the name of the entity.  The default implementation looks for
<var>ref</var> in the instance (or class) variable <tt class="member">entitydefs</tt>
which should be a mapping from entity names to corresponding
translations.  If no translation is available for <var>ref</var>, this
method returns <code>None</code>.  This method is called by the default
<tt class="method">handle_entityref()</tt> implementation and by the attribute value
parser.

<span class="versionnote">New in version 2.5.</span>

</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1685' xml:id='l2h-1685' class="method">handle_comment</tt></b>(</nobr></td>
  <td><var>comment</var>)</td></tr></table></dt>
<dd>
This method is called when a comment is encountered.  The
<var>comment</var> argument is a string containing the text between the
"<tt class="samp">&lt;!--</tt>" and "<tt class="samp">--&gt;</tt>" delimiters, but not the delimiters
themselves.  For example, the comment "<tt class="samp">&lt;!--text--&gt;</tt>" will
cause this method to be called with the argument <code>'text'</code>.  The
default method does nothing.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1686' xml:id='l2h-1686' class="method">handle_decl</tt></b>(</nobr></td>
  <td><var>data</var>)</td></tr></table></dt>
<dd>
Method called when an SGML declaration is read by the parser.  In
practice, the <code>DOCTYPE</code> declaration is the only thing observed in
HTML, but the parser does not discriminate among different (or broken)
declarations.  Internal subsets in a <code>DOCTYPE</code> declaration are
not supported.  The <var>data</var> parameter will be the entire contents
of the declaration inside the <code>&lt;!</code>...<code>&gt;</code> markup.  The
default implementation does nothing.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1687' xml:id='l2h-1687' class="method">report_unbalanced</tt></b>(</nobr></td>
  <td><var>tag</var>)</td></tr></table></dt>
<dd>
This method is called when an end tag is found which does not
correspond to any open element.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1688' xml:id='l2h-1688' class="method">unknown_starttag</tt></b>(</nobr></td>
  <td><var>tag, attributes</var>)</td></tr></table></dt>
<dd>
This method is called to process an unknown start tag.  It is intended
to be overridden by a derived class; the base class implementation
does nothing.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1689' xml:id='l2h-1689' class="method">unknown_endtag</tt></b>(</nobr></td>
  <td><var>tag</var>)</td></tr></table></dt>
<dd>
This method is called to process an unknown end tag.  It is intended
to be overridden by a derived class; the base class implementation
does nothing.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1690' xml:id='l2h-1690' class="method">unknown_charref</tt></b>(</nobr></td>
  <td><var>ref</var>)</td></tr></table></dt>
<dd>
This method is called to process unresolvable numeric character
references.  Refer to <tt class="method">handle_charref()</tt> to determine what is
handled by default.  It is intended to be overridden by a derived
class; the base class implementation does nothing.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-1691' xml:id='l2h-1691' class="method">unknown_entityref</tt></b>(</nobr></td>
  <td><var>ref</var>)</td></tr></table></dt>
<dd>
This method is called to process an unknown entity reference.  It is
intended to be overridden by a derived class; the base class
implementation does nothing.
</dl>

<p>
Apart from overriding or extending the methods listed above, derived
classes may also define methods of the following form to define
processing of specific tags.  Tag names in the input stream are case
independent; the <var>tag</var> occurring in method names must be in lower
case:

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b>start_<var>tag</var></b>(</nobr></td>
  <td><var>attributes</var>)</td></tr></table></dt>
<dd>
This method is called to process an opening tag <var>tag</var>.  It has
preference over <tt class="method">do_<var>tag</var>()</tt>.  The
<var>attributes</var> argument has the same meaning as described for
<tt class="method">handle_starttag()</tt> above.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b>do_<var>tag</var></b>(</nobr></td>
  <td><var>attributes</var>)</td></tr></table></dt>
<dd>
This method is called to process an opening tag <var>tag</var> 
for which no <tt class="method">start_<var>tag</var></tt> method is defined.  
The <var>attributes</var> argument
has the same meaning as described for <tt class="method">handle_starttag()</tt> above.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b>end_<var>tag</var></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
This method is called to process a closing tag <var>tag</var>.
</dl>

<p>
Note that the parser maintains a stack of open elements for which no
end tag has been found yet.  Only tags processed by
<tt class="method">start_<var>tag</var>()</tt> are pushed on this stack.  Definition of an
<tt class="method">end_<var>tag</var>()</tt> method is optional for these tags.  For tags
processed by <tt class="method">do_<var>tag</var>()</tt> or by <tt class="method">unknown_tag()</tt>, no
<tt class="method">end_<var>tag</var>()</tt> method must be defined; if defined, it will
not be used.  If both <tt class="method">start_<var>tag</var>()</tt> and
<tt class="method">do_<var>tag</var>()</tt> methods exist for a tag, the
<tt class="method">start_<var>tag</var>()</tt> method takes precedence.

<div class="navigation">
<div class='online-navigation'>
<p></p><hr />
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="8.1.1 example HTML Parser"
  href="htmlparser-example.html"><img src='../icons/previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></a></td>
<td class='online-navigation'><a rel="parent" title="8. structured Markup Processing"
  href="markup.html"><img src='../icons/up.png'
  border='0' height='32'  alt='Up one Level' width='32' /></a></td>
<td class='online-navigation'><a rel="next" title="8.3 htmllib  "
  href="module-htmllib.html"><img src='../icons/next.png'
  border='0' height='32'  alt='Next Page' width='32' /></a></td>
<td align="center" width="100%">Python Library Reference</td>
<td class='online-navigation'><a rel="contents" title="Table of Contents"
  href="contents.html"><img src='../icons/contents.png'
  border='0' height='32'  alt='Contents' width='32' /></a></td>
<td class='online-navigation'><a href="modindex.html" title="Module Index"><img src='../icons/modules.png'
  border='0' height='32'  alt='Module Index' width='32' /></a></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='../icons/index.png'
  border='0' height='32'  alt='Index' width='32' /></a></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="htmlparser-example.html">8.1.1 Example HTML Parser</a>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="markup.html">8. Structured Markup Processing</a>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="module-htmllib.html">8.3 htmllib  </a>
</div>
</div>
<hr />
<span class="release-info">Release 2.5.1, documentation updated on 18th April, 2007.</span>
</div>
<!--End of Navigation Panel-->
<address>
See <i><a href="about.html">About this document...</a></i> for information on suggesting changes.
</address>
</body>
</html>
