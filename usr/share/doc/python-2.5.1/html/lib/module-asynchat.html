<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<link rel="STYLESHEET" href="lib.css" type='text/css' />
<link rel="SHORTCUT ICON" href="../icons/pyfav.png" type="image/png" />
<link rel='start' href='../index.html' title='Python documentation Index' />
<link rel="first" href="lib.html" title='Python library Reference' />
<link rel='contents' href='contents.html' title="Contents" />
<link rel='index' href='genindex.html' title='Index' />
<link rel='last' href='about.html' title='About this document...' />
<link rel='help' href='about.html' title='About this document...' />
<link rel="prev" href="module-asyncore.html" />
<link rel="parent" href="ipc.html" />
<link rel="next" href="node552.html" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name='aesop' content='information' />
<title>17.6 asynchat -- Asynchronous socket command/response handler</title>
</head>
<body>
<div class="navigation">
<div id='top-navigation-panel' xml:id='top-navigation-panel'>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="17.5.1 asyncore Example basic"
  href="asyncore-example.html"><img src='../icons/previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></a></td>
<td class='online-navigation'><a rel="parent" title="17. interprocess Communication and"
  href="ipc.html"><img src='../icons/up.png'
  border='0' height='32'  alt='Up one Level' width='32' /></a></td>
<td class='online-navigation'><a rel="next" title="17.6.1 asynchat - Auxiliary"
  href="node552.html"><img src='../icons/next.png'
  border='0' height='32'  alt='Next Page' width='32' /></a></td>
<td align="center" width="100%">Python Library Reference</td>
<td class='online-navigation'><a rel="contents" title="Table of Contents"
  href="contents.html"><img src='../icons/contents.png'
  border='0' height='32'  alt='Contents' width='32' /></a></td>
<td class='online-navigation'><a href="modindex.html" title="Module Index"><img src='../icons/modules.png'
  border='0' height='32'  alt='Module Index' width='32' /></a></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='../icons/index.png'
  border='0' height='32'  alt='Index' width='32' /></a></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="asyncore-example.html">17.5.1 asyncore Example basic</a>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="ipc.html">17. Interprocess Communication and</a>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="node552.html">17.6.1 asynchat - Auxiliary</a>
</div>
<hr /></div>
</div>
<!--End of Navigation Panel-->

<h1><a name="SECTION0019600000000000000000">
17.6 <tt class="module">asynchat</tt> --
         Asynchronous socket command/response handler</a>
</h1>

<p>
<a name="module-asynchat"></a>

<p>
This module builds on the <tt class="module"><a href="module-asyncore.html">asyncore</a></tt> infrastructure,
simplifying asynchronous clients and servers and making it easier to
handle protocols whose elements are terminated by arbitrary strings, or
are of variable length. <tt class="module"><a href="module-asynchat.html">asynchat</a></tt> defines the abstract class
<tt class="class">async_chat</tt> that you subclass, providing implementations of the
<tt class="method">collect_incoming_data()</tt> and <tt class="method">found_terminator()</tt>
methods. It uses the same asynchronous loop as <tt class="module"><a href="module-asyncore.html">asyncore</a></tt>, and
the two types of channel, <tt class="class">asyncore.dispatcher</tt> and
<tt class="class">asynchat.async_chat</tt>, can freely be mixed in the channel map.
Typically an <tt class="class">asyncore.dispatcher</tt> server channel generates new
<tt class="class">asynchat.async_chat</tt> channel objects as it receives incoming
connection requests. 

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<tt id='l2h-3769' xml:id='l2h-3769' class="class">async_chat</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  This class is an abstract subclass of <tt class="class">asyncore.dispatcher</tt>. To make
  practical use of the code you must subclass <tt class="class">async_chat</tt>, providing
  meaningful <tt class="method">collect_incoming_data()</tt> and <tt class="method">found_terminator()</tt>
  methods. The <tt class="class">asyncore.dispatcher</tt> methods can be
  used, although not all make sense in a message/response context.  

<p>
Like <tt class="class">asyncore.dispatcher</tt>, <tt class="class">async_chat</tt> defines a set of events
  that are generated by an analysis of socket conditions after a
  <tt class="cfunction">select()</tt> call. Once the polling loop has been started the
  <tt class="class">async_chat</tt> object's methods are called by the event-processing
  framework with no action on the part of the programmer.

<p>
Unlike <tt class="class">asyncore.dispatcher</tt>, <tt class="class">async_chat</tt> allows you to define
  a first-in-first-out queue (fifo) of <em>producers</em>. A producer need have
  only one method, <tt class="method">more()</tt>, which should return data to be transmitted
  on the channel. The producer indicates exhaustion (<em>i.e.</em> that it contains
  no more data) by having its <tt class="method">more()</tt> method return the empty string. At
  this point the <tt class="class">async_chat</tt> object removes the producer from the fifo
  and starts using the next producer, if any. When the producer fifo is empty
  the <tt class="method">handle_write()</tt> method does nothing. You use the channel object's
  <tt class="method">set_terminator()</tt> method to describe how to recognize the end
  of, or an important breakpoint in, an incoming transmission from the
  remote endpoint.

<p>
To build a functioning <tt class="class">async_chat</tt> subclass your 
  input methods <tt class="method">collect_incoming_data()</tt> and
  <tt class="method">found_terminator()</tt> must handle the data that the channel receives
  asynchronously. The methods are described below.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3770' xml:id='l2h-3770' class="method">close_when_done</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  Pushes a <code>None</code> on to the producer fifo. When this producer is
  popped off the fifo it causes the channel to be closed.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3771' xml:id='l2h-3771' class="method">collect_incoming_data</tt></b>(</nobr></td>
  <td><var>data</var>)</td></tr></table></dt>
<dd>
  Called with <var>data</var> holding an arbitrary amount of received data.
  The default method, which must be overridden, raises a <tt class="exception">NotImplementedError</tt> exception.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3772' xml:id='l2h-3772' class="method">discard_buffers</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  In emergencies this method will discard any data held in the input and/or
  output buffers and the producer fifo.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3773' xml:id='l2h-3773' class="method">found_terminator</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  Called when the incoming data stream  matches the termination condition
  set by <tt class="method">set_terminator</tt>. The default method, which must be overridden,
  raises a <tt class="exception">NotImplementedError</tt> exception. The buffered input data should
  be available via an instance attribute.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3774' xml:id='l2h-3774' class="method">get_terminator</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  Returns the current terminator for the channel.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3775' xml:id='l2h-3775' class="method">handle_close</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  Called when the channel is closed. The default method silently closes
  the channel's socket.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3776' xml:id='l2h-3776' class="method">handle_read</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  Called when a read event fires on the channel's socket in the
  asynchronous loop. The default method checks for the termination
  condition established by <tt class="method">set_terminator()</tt>, which can be either
  the appearance of a particular string in the input stream or the receipt
  of a particular number of characters. When the terminator is found,
  <tt class="method">handle_read</tt> calls the <tt class="method">found_terminator()</tt> method after
  calling <tt class="method">collect_incoming_data()</tt> with any data preceding the
  terminating condition.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3777' xml:id='l2h-3777' class="method">handle_write</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  Called when the application may write data to the channel.  
  The default method calls the <tt class="method">initiate_send()</tt> method, which in turn
  will call <tt class="method">refill_buffer()</tt> to collect data from the producer
  fifo associated with the channel.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3778' xml:id='l2h-3778' class="method">push</tt></b>(</nobr></td>
  <td><var>data</var>)</td></tr></table></dt>
<dd>
  Creates a <tt class="class">simple_producer</tt> object (<em>see below</em>) containing the data and
  pushes it on to the channel's <code>producer_fifo</code> to ensure its
  transmission. This is all you need to do to have the channel write
  the data out to the network, although it is possible to use your
  own producers in more complex schemes to implement encryption and
  chunking, for example.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3779' xml:id='l2h-3779' class="method">push_with_producer</tt></b>(</nobr></td>
  <td><var>producer</var>)</td></tr></table></dt>
<dd>
  Takes a producer object and adds it to the producer fifo associated with
  the channel. When all currently-pushed producers have been exhausted
  the channel will consume this producer's data by calling its
  <tt class="method">more()</tt> method and send the data to the remote endpoint. 
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3780' xml:id='l2h-3780' class="method">readable</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  Should return <code>True</code> for the channel to be included in the set of
  channels tested by the <tt class="cfunction">select()</tt> loop for readability.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3781' xml:id='l2h-3781' class="method">refill_buffer</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  Refills the output buffer by calling the <tt class="method">more()</tt> method of the
  producer at the head of the fifo. If it is exhausted then the
  producer is popped off the fifo and the next producer is activated.
  If the current producer is, or becomes, <code>None</code> then the channel
  is closed.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3782' xml:id='l2h-3782' class="method">set_terminator</tt></b>(</nobr></td>
  <td><var>term</var>)</td></tr></table></dt>
<dd>
  Sets the terminating condition to be recognised on the channel. <code>term</code>
  may be any of three types of value, corresponding to three different ways
  to handle incoming protocol data.

<p>
<div class="center"><table class="realtable">
  <thead>
    <tr>
      <th class="left"  >term</th>
      <th class="left"  >Description</th>
      </tr>
    </thead>
  <tbody>
    <tr><td class="left"   valign="baseline"><em>string</em></td>
        <td class="left"  >Will call <tt class="method">found_terminator()</tt> when the
                string is found in the input stream</td></tr>
    <tr><td class="left"   valign="baseline"><em>integer</em></td>
        <td class="left"  >Will call <tt class="method">found_terminator()</tt> when the
                indicated number of characters have been received</td></tr>
    <tr><td class="left"   valign="baseline"><code>None</code></td>
        <td class="left"  >The channel continues to collect data forever</td></tr></tbody>
</table></div>

<p>
Note that any data following the terminator will be available for reading by
  the channel after <tt class="method">found_terminator()</tt> is called.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-3783' xml:id='l2h-3783' class="method">writable</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
  Should return <code>True</code> as long as items remain on the producer fifo,
  or the channel is connected and the channel's output buffer is non-empty.
</dl>

<p>

<p><br /></p><hr class='online-navigation' />
<div class='online-navigation'>
<!--Table of Child-Links-->
<a name="CHILD_LINKS"><strong>Subsections</strong></a>

<ul class="ChildLinks">
<li><a href="node552.html">17.6.1 asynchat - Auxiliary Classes and Functions</a>
<li><a href="asynchat-example.html">17.6.2 asynchat Example</a>
</ul>
<!--End of Table of Child-Links-->
</div>

<div class="navigation">
<div class='online-navigation'>
<p></p><hr />
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="17.5.1 asyncore Example basic"
  href="asyncore-example.html"><img src='../icons/previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></a></td>
<td class='online-navigation'><a rel="parent" title="17. interprocess Communication and"
  href="ipc.html"><img src='../icons/up.png'
  border='0' height='32'  alt='Up one Level' width='32' /></a></td>
<td class='online-navigation'><a rel="next" title="17.6.1 asynchat - Auxiliary"
  href="node552.html"><img src='../icons/next.png'
  border='0' height='32'  alt='Next Page' width='32' /></a></td>
<td align="center" width="100%">Python Library Reference</td>
<td class='online-navigation'><a rel="contents" title="Table of Contents"
  href="contents.html"><img src='../icons/contents.png'
  border='0' height='32'  alt='Contents' width='32' /></a></td>
<td class='online-navigation'><a href="modindex.html" title="Module Index"><img src='../icons/modules.png'
  border='0' height='32'  alt='Module Index' width='32' /></a></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='../icons/index.png'
  border='0' height='32'  alt='Index' width='32' /></a></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="asyncore-example.html">17.5.1 asyncore Example basic</a>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="ipc.html">17. Interprocess Communication and</a>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="node552.html">17.6.1 asynchat - Auxiliary</a>
</div>
</div>
<hr />
<span class="release-info">Release 2.5.1, documentation updated on 18th April, 2007.</span>
</div>
<!--End of Navigation Panel-->
<address>
See <i><a href="about.html">About this document...</a></i> for information on suggesting changes.
</address>
</body>
</html>
